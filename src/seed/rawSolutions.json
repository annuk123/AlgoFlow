[
 
{
  "slug": "two-sum",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function twoSum(nums, target) {\n const map = new Map(); // stores num -> index\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return null;\n}",
      "explanation": "## ðŸ“ Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize a Map:**\n   - `const map = new Map();`\n   - The map stores each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for (let i = 0; i < nums.length; i++)`\n   - Go through each element one by one.\n\n **Calculate the complement:**\n   - `const complement = target - nums[i];`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the map:**\n   - `if (map.has(complement))`\n   - If found, we have the solution.\n\n **Return the indices:**\n   - `return [map.get(complement), i];`\n   - Return the index of the complement and the current index.\n\n **Store the current number in the map:**\n   - `map.set(nums[i], i);`\n   - If the complement is not found, store the current number and its index.\n\n **Return null if no solution:**\n   - `return null;`\n   - If no pair adds up to the target, return `null`.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```js\nnums = [2, 7, 11, 15], target = 9\n```\n\n**Process:**\n- i = 0, nums[0] = 2 â†’ complement = 7 â†’ not in map â†’ store 2 at index 0\n- i = 1, nums[1] = 7 â†’ complement = 2 â†’ found in map â†’ return [0, 1]\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n- Hash maps provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    },

    {
      "language": "Python",
      "code": "class Solution:\n    def twoSum(self, nums, target):\n        map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in map:\n                return (map[complement], i)\n            map[num] = i\n        return None",
      "explanation": "## ðŸ“ Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize a Dictionary:**\n   - `map = {}`\n   - This dictionary will store each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for i, num in enumerate(nums):`\n   - Iterate through each element with its index.\n\n **Calculate the complement:**\n   - `complement = target - num`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the dictionary:**\n   - `if complement in map:`\n   - If found, we have our solution.\n\n **Return the indices:**\n   - `return (map[complement], i)`\n   - Return the index of the complement and the current index.\n\n **Store the current number in the dictionary:**\n   - `map[num] = i`\n   - If the complement is not found, store the current number and its index.\n\n **Return None if no solution:**\n   - `return None`\n   - If no pair adds up to the target, return `None`.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```python\nnums = [2, 7, 11, 15], target = 9\n```\n\n**Process:**\n- i = 0, nums[0] = 2 â†’ complement = 7 â†’ not in map â†’ store 2 at index 0\n- i = 1, nums[1] = 7 â†’ complement = 2 â†’ found in map â†’ return (0, 1)\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n- Dictionaries provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    }, 
    {
      "language": "Java",
      "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] { -1, -1 };  // No solution found\n    }\n}",
      "explanation": "## ðŸ“ Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Import Required Classes:**\n   - `import java.util.HashMap;`\n   - `import java.util.Map;`\n   - These classes are used for creating a map to store numbers and their indices.\n\n **Define the Method:**\n   - `public int[] twoSum(int[] nums, int target)`\n   - This method takes an array of integers and a target integer as input.\n\n **Initialize a Map:**\n   - `Map<Integer, Integer> map = new HashMap<>();`\n   - The map will store each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for (int i = 0; i < nums.length; i++)`\n   - Iterate through each element with its index.\n\n **Calculate the complement:**\n   - `int complement = target - nums[i];`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the map:**\n   - `if (map.containsKey(complement))`\n   - If found, we have our solution.\n\n **Return the indices:**\n   - `return new int[] { map.get(complement), i };\n`- Return the index of the complement and the current index.\n\n **Store the current number in the map:**\n   - `map.put(nums[i], i);`\n   - If the complement is not found, store the current number and its index.\n\n **Return default value if no solution:**\n   - `return new int[] { -1, -1 };`\n   - If no pair adds up to the target, return an array indicating no solution was found.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```java\nint[] nums = {2, 7, 11, 15}, target = 9;\n```\n\n**Process:**\n- i = 0, nums[0] = 2 â†’ complement = 7 â†’ not in map â†’ store 2 at index \n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n-- Hash maps provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    }
  ]
},

{
  "slug": "add-two-numbers",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function addTwoNumbers(l1, l2) {\n    let dummyHead = { val: 0, next: null };\n    let current = dummyHead;\n    let carry = 0;\n\n    while (l1 || l2 || carry) {\n        const sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;\n        carry = Math.floor(sum / 10);\n        current.next = { val: sum % 10, next: null };\n        current = current.next;\n        if (l1) l1 = l1.next;\n        if (l2) l2 = l2.next;\n    }\n\n    return dummyHead.next;\n}",
      "explanation": "## ðŸ“ Problem Recap\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize a Dummy Head:**\n   - `let dummyHead = { val: 0, next: null }`\n   - This will help in easily returning the result linked list.\n\n **Initialize Current Pointer:**\n   - `let current = dummyHead`\n   - This pointer will traverse and build the new linked list.\n\n **Initialize Carry Variable:**\n   - `let carry = 0`\n   - This will hold any carry-over value during addition.\n\n **Loop Until All Nodes Processed:**\n   - `while (l1 || l2 || carry)`\n   - Continue until both lists are fully traversed and no carry remains.\n\n **Calculate Sum:**\n   - `const sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry`\n   - Add values from both nodes and the carry.\n\n **Update Carry:**\n   - `carry = Math.floor(sum / 10)`\n   - Calculate the new carry for the next iteration.\n\n **Create New Node:**\n   - `current.next = { val: sum % 10, next: null }`\n   - Create a new node with the digit value and attach it to the result list.\n   - Move the current pointer to the new node.\n\n **Return the Result:**\n   - `return dummyHead.next`\n   - Skip the dummy head and return the actual result list.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```javascript\nconst l1 = { val: 2, next: { val: 4, next: { val: 3, next: null } } };\nconst l2 = { val: 5, next: { val: 6, next: { val: 4, next: null } } };\n```\n\n**Process:**\n- Initialize dummy head and current pointer.\n- Loop through both lists and add corresponding digits.\n- Create new nodes for the result list.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(max(m, n))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Linked lists can represent large numbers.\n- Reverse order allows easy addition with carry.\n- Dummy head simplifies result list construction."
},
    {
      "language": "Python",
      "code": "class Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummyHead = ListNode(0)\n        current = dummyHead\n        carry = 0\n\n        while l1 or l2 or carry:\n            sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n            carry = sum // 10\n            current.next = ListNode(sum % 10)\n            current = current.next\n            if l1: l1 = l1.next\n            if l2: l2 = l2.next\n\n        return dummyHead.next",
      "explanation": "## ðŸ“ Problem Recap\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Define the ListNode Class:**\n   - `class ListNode:`\n   - This class represents a node in the linked list.\n   - It has a value (`val`) and a pointer to the next node (`next`).\n\n **Initialize a Dummy Head:**\n   - `dummyHead = ListNode(0)`\n   - This will help in easily returning the result linked list.\n\n **Initialize Current Pointer:**\n   - `current = dummyHead`\n   - This pointer will traverse and build the new linked list.\n\n **Initialize Carry Variable:**\n   - `carry = 0`\n   - This will hold any carry-over value during addition.\n\n **Loop Until All Nodes Processed:**\n   - `while l1 or l2 or carry:`\n   - Continue until both lists are fully traversed and no carry remains.\n\n **Calculate Sum:**\n   - `sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry`\n   - Add values from both nodes and the carry.\n   - `carry = sum // 10`\n   - Calculate the new carry for the next iteration.\n\n **Create New Node:**\n   - `current.next = ListNode(sum % 10)`\n   - Create a new node with the digit value and attach it to the result list.\n   - Move the current pointer to the new node.\n\n **Return the Result:**\n   - `return dummyHead.next`\n   - Skip the dummy head and return the actual result list.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```python\nl1 = ListNode(2, ListNode(4, ListNode(3)))\nl2 = ListNode(5, ListNode(6, ListNode(4)))\n```\n\n**Process:**\n- Initialize dummy head and current pointer.\n- Loop through both lists and add corresponding digits.\n- Create new nodes for the result list.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(max(m, n))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Linked lists can represent large numbers.\n- Reverse order allows easy addition with carry.\n- Dummy head simplifies result list construction."
    },

    {
      "language": "Java",
      "code": "public class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode current = dummyHead;\n        int carry = 0;\n\n        while (l1 != null || l2 != null || carry != 0) {\n            int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\n            carry = sum / 10;\n            current.next = new ListNode(sum % 10);\n            current = current.next;\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        return dummyHead.next;\n    }\n}",
      "explanation": "## ðŸ“ Problem Recap\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Define the ListNode Class:**\n   - `class ListNode` defines a node in the linked list with a value (`val`) and a pointer to the next node (`next`).\n\n **Initialize a Dummy Head:**\n   - `ListNode dummyHead = new ListNode(0)` creates a dummy head to simplify result list construction.\n\n **Initialize Current Pointer:**\n   - `ListNode current = dummyHead` will traverse and build the new linked list.\n\n **Initialize Carry Variable:**\n   - `int carry = 0` holds any carry-over value during addition.\n\n **Loop Until All Nodes Processed:**\n   - `while (l1 != null || l2 != null || carry != 0)` continues until both lists are fully traversed and no carry remains.\n\n **Calculate Sum:**\n   - `int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry` adds values from both nodes and the carry.\n   - `carry = sum / 10` calculates the new carry for the next iteration.\n\n **Create New Node:**\n   - `current.next = new ListNode(sum % 10)` creates a new node with the digit value and attaches it to the result list.\n   - Move the current pointer to the new node.\n\n **Return the Result:**\n   - `return dummyHead.next` skips the dummy head and returns the actual result list.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```java\nListNode l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\nListNode l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n```\n\n**Process:**\n- Initialize dummy head and current pointer.\n- Loop through both lists and add corresponding digits.\n- Create new nodes for the result list.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(max(m, n))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Linked lists can represent large numbers.\n- Reverse order allows easy addition with carry.\n- Dummy head simplifies result list construction."
    }

]

}
]