[
 
{
  "slug": "two-sum",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function twoSum(nums, target) {\n const map = new Map(); // stores num -> index\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return null;\n}",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize a Map:**\n   - `const map = new Map();`\n   - The map stores each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for (let i = 0; i < nums.length; i++)`\n   - Go through each element one by one.\n\n **Calculate the complement:**\n   - `const complement = target - nums[i];`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the map:**\n   - `if (map.has(complement))`\n   - If found, we have the solution.\n\n **Return the indices:**\n   - `return [map.get(complement), i];`\n   - Return the index of the complement and the current index.\n\n **Store the current number in the map:**\n   - `map.set(nums[i], i);`\n   - If the complement is not found, store the current number and its index.\n\n **Return null if no solution:**\n   - `return null;`\n   - If no pair adds up to the target, return `null`.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```js\nnums = [2, 7, 11, 15], target = 9\n```\n\n**Process:**\n- i = 0, nums[0] = 2 → complement = 7 → not in map → store 2 at index 0\n- i = 1, nums[1] = 7 → complement = 2 → found in map → return [0, 1]\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n- Hash maps provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    },

    {
      "language": "Python",
      "code": "class Solution:\n    def twoSum(self, nums, target):\n        map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in map:\n                return (map[complement], i)\n            map[num] = i\n        return None",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize a Dictionary:**\n   - `map = {}`\n   - This dictionary will store each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for i, num in enumerate(nums):`\n   - Iterate through each element with its index.\n\n **Calculate the complement:**\n   - `complement = target - num`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the dictionary:**\n   - `if complement in map:`\n   - If found, we have our solution.\n\n **Return the indices:**\n   - `return (map[complement], i)`\n   - Return the index of the complement and the current index.\n\n **Store the current number in the dictionary:**\n   - `map[num] = i`\n   - If the complement is not found, store the current number and its index.\n\n **Return None if no solution:**\n   - `return None`\n   - If no pair adds up to the target, return `None`.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```python\nnums = [2, 7, 11, 15], target = 9\n```\n\n**Process:**\n- i = 0, nums[0] = 2 → complement = 7 → not in map → store 2 at index 0\n- i = 1, nums[1] = 7 → complement = 2 → found in map → return (0, 1)\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n- Dictionaries provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    }, 
    {
      "language": "Java",
      "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] { -1, -1 };  // No solution found\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Import Required Classes:**\n   - `import java.util.HashMap;`\n   - `import java.util.Map;`\n   - These classes are used for creating a map to store numbers and their indices.\n\n **Define the Method:**\n   - `public int[] twoSum(int[] nums, int target)`\n   - This method takes an array of integers and a target integer as input.\n\n **Initialize a Map:**\n   - `Map<Integer, Integer> map = new HashMap<>();`\n   - The map will store each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for (int i = 0; i < nums.length; i++)`\n   - Iterate through each element with its index.\n\n **Calculate the complement:**\n   - `int complement = target - nums[i];`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the map:**\n   - `if (map.containsKey(complement))`\n   - If found, we have our solution.\n\n **Return the indices:**\n   - `return new int[] { map.get(complement), i };\n`- Return the index of the complement and the current index.\n\n **Store the current number in the map:**\n   - `map.put(nums[i], i);`\n   - If the complement is not found, store the current number and its index.\n\n **Return default value if no solution:**\n   - `return new int[] { -1, -1 };`\n   - If no pair adds up to the target, return an array indicating no solution was found.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```java\nint[] nums = {2, 7, 11, 15}, target = 9;\n```\n\n**Process:**\n- i = 0, nums[0] = 2 → complement = 7 → not in map → store 2 at index \n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n-- Hash maps provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    }
  ]
},

{
  "slug": "add-two-numbers",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function addTwoNumbers(l1, l2) {\n    let dummyHead = { val: 0, next: null };\n    let current = dummyHead;\n    let carry = 0;\n\n    while (l1 || l2 || carry) {\n        const sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry;\n        carry = Math.floor(sum / 10);\n        current.next = { val: sum % 10, next: null };\n        current = current.next;\n        if (l1) l1 = l1.next;\n        if (l2) l2 = l2.next;\n    }\n\n    return dummyHead.next;\n}",
      "explanation": "## 📝 Problem Recap\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize a Dummy Head:**\n   - `let dummyHead = { val: 0, next: null }`\n   - This will help in easily returning the result linked list.\n\n **Initialize Current Pointer:**\n   - `let current = dummyHead`\n   - This pointer will traverse and build the new linked list.\n\n **Initialize Carry Variable:**\n   - `let carry = 0`\n   - This will hold any carry-over value during addition.\n\n **Loop Until All Nodes Processed:**\n   - `while (l1 || l2 || carry)`\n   - Continue until both lists are fully traversed and no carry remains.\n\n **Calculate Sum:**\n   - `const sum = (l1 ? l1.val : 0) + (l2 ? l2.val : 0) + carry`\n   - Add values from both nodes and the carry.\n\n **Update Carry:**\n   - `carry = Math.floor(sum / 10)`\n   - Calculate the new carry for the next iteration.\n\n **Create New Node:**\n   - `current.next = { val: sum % 10, next: null }`\n   - Create a new node with the digit value and attach it to the result list.\n   - Move the current pointer to the new node.\n\n **Return the Result:**\n   - `return dummyHead.next`\n   - Skip the dummy head and return the actual result list.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```javascript\nconst l1 = { val: 2, next: { val: 4, next: { val: 3, next: null } } };\nconst l2 = { val: 5, next: { val: 6, next: { val: 4, next: null } } };\n```\n\n**Process:**\n- Initialize dummy head and current pointer.\n- Loop through both lists and add corresponding digits.\n- Create new nodes for the result list.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(max(m, n))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Linked lists can represent large numbers.\n- Reverse order allows easy addition with carry.\n- Dummy head simplifies result list construction."
},
    {
      "language": "Python",
      "code": "class Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummyHead = ListNode(0)\n        current = dummyHead\n        carry = 0\n\n        while l1 or l2 or carry:\n            sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry\n            carry = sum // 10\n            current.next = ListNode(sum % 10)\n            current = current.next\n            if l1: l1 = l1.next\n            if l2: l2 = l2.next\n\n        return dummyHead.next",
      "explanation": "## 📝 Problem Recap\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Define the ListNode Class:**\n   - `class ListNode:`\n   - This class represents a node in the linked list.\n   - It has a value (`val`) and a pointer to the next node (`next`).\n\n **Initialize a Dummy Head:**\n   - `dummyHead = ListNode(0)`\n   - This will help in easily returning the result linked list.\n\n **Initialize Current Pointer:**\n   - `current = dummyHead`\n   - This pointer will traverse and build the new linked list.\n\n **Initialize Carry Variable:**\n   - `carry = 0`\n   - This will hold any carry-over value during addition.\n\n **Loop Until All Nodes Processed:**\n   - `while l1 or l2 or carry:`\n   - Continue until both lists are fully traversed and no carry remains.\n\n **Calculate Sum:**\n   - `sum = (l1.val if l1 else 0) + (l2.val if l2 else 0) + carry`\n   - Add values from both nodes and the carry.\n   - `carry = sum // 10`\n   - Calculate the new carry for the next iteration.\n\n **Create New Node:**\n   - `current.next = ListNode(sum % 10)`\n   - Create a new node with the digit value and attach it to the result list.\n   - Move the current pointer to the new node.\n\n **Return the Result:**\n   - `return dummyHead.next`\n   - Skip the dummy head and return the actual result list.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```python\nl1 = ListNode(2, ListNode(4, ListNode(3)))\nl2 = ListNode(5, ListNode(6, ListNode(4)))\n```\n\n**Process:**\n- Initialize dummy head and current pointer.\n- Loop through both lists and add corresponding digits.\n- Create new nodes for the result list.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(max(m, n))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Linked lists can represent large numbers.\n- Reverse order allows easy addition with carry.\n- Dummy head simplifies result list construction."
    },

    {
      "language": "Java",
      "code": "public class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode current = dummyHead;\n        int carry = 0;\n\n        while (l1 != null || l2 != null || carry != 0) {\n            int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry;\n            carry = sum / 10;\n            current.next = new ListNode(sum % 10);\n            current = current.next;\n            if (l1 != null) l1 = l1.next;\n            if (l2 != null) l2 = l2.next;\n        }\n\n        return dummyHead.next;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return it as a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Define the ListNode Class:**\n   - `class ListNode` defines a node in the linked list with a value (`val`) and a pointer to the next node (`next`).\n\n **Initialize a Dummy Head:**\n   - `ListNode dummyHead = new ListNode(0)` creates a dummy head to simplify result list construction.\n\n **Initialize Current Pointer:**\n   - `ListNode current = dummyHead` will traverse and build the new linked list.\n\n **Initialize Carry Variable:**\n   - `int carry = 0` holds any carry-over value during addition.\n\n **Loop Until All Nodes Processed:**\n   - `while (l1 != null || l2 != null || carry != 0)` continues until both lists are fully traversed and no carry remains.\n\n **Calculate Sum:**\n   - `int sum = (l1 != null ? l1.val : 0) + (l2 != null ? l2.val : 0) + carry` adds values from both nodes and the carry.\n   - `carry = sum / 10` calculates the new carry for the next iteration.\n\n **Create New Node:**\n   - `current.next = new ListNode(sum % 10)` creates a new node with the digit value and attaches it to the result list.\n   - Move the current pointer to the new node.\n\n **Return the Result:**\n   - `return dummyHead.next` skips the dummy head and returns the actual result list.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```java\nListNode l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\nListNode l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n```\n\n**Process:**\n- Initialize dummy head and current pointer.\n- Loop through both lists and add corresponding digits.\n- Create new nodes for the result list.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(max(m, n))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Linked lists can represent large numbers.\n- Reverse order allows easy addition with carry.\n- Dummy head simplifies result list construction."
    }

]

},
{
  "slug": "3-longest-substring-without-repeating-characters",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function lengthOfLongestSubstring(s) {\n    const charIndexMap = new Map();\n    let maxLength = 0;\n    let start = 0;\n\n    for (let end = 0; end < s.length; end++) {\n        if (charIndexMap.has(s[end])) {\n            start = Math.max(charIndexMap.get(s[end]) + 1, start);\n        }\n        charIndexMap.set(s[end], end);\n        maxLength = Math.max(maxLength, end - start + 1);\n    }\n\n    return maxLength;\n}",
      "explanation": "## 📝 Problem Recap\nYou are given a string and need to find the length of the longest substring without repeating characters.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers and Map:**\n   - Use a `Map` to track the last seen index of each character.\n   - Initialize `start` pointer at 0 and `maxLength` at 0.\n\n **Expand the Window:**\n   - Loop with `end` pointer over each character in the string.\n   - If the character is already in the map and its index is within the current window, update `start`.\n\n **Update Map and Max Length:**\n   - Update the character's latest index in the map.\n   - Calculate the current window length and update `maxLength` if it's larger.\n\n **Return Result:**\n   - After the loop, `maxLength` contains the length of the longest substring without repeating characters."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        charIndexMap = {}\n        maxLength = 0\n        start = 0\n\n        for end in range(len(s)):\n            if s[end] in charIndexMap and charIndexMap[s[end]] >= start:\n                start = charIndexMap[s[end]] + 1\n            charIndexMap[s[end]] = end\n            maxLength = max(maxLength, end - start + 1)\n\n        return maxLength",
      "explanation": "## 📝 Problem Recap\nYou are given a string and need to find the length of the longest substring without repeating characters.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers and Dictionary:**\n   - Use a dictionary to track the last seen index of each character.\n   - Initialize `start` pointer at 0 and `maxLength` at 0.\n\n **Expand the Window:**\n   - Loop with `end` pointer over each character in the string.\n   - If the character is already in the dictionary and its index is within the current window, update `start`.\n\n **Update Dictionary and Max Length:**\n   - Update the character's latest index in the dictionary.\n   - Calculate the current window length and update `maxLength` if it's larger.\n\n **Return Result:**\n   - After the loop, `maxLength` contains the length of the longest substring without repeating characters."
    },
    {
      "language": "Java",
      "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Map<Character, Integer> charIndexMap = new HashMap<>();\n        int maxLength = 0;\n        int start = 0;\n\n        for (int end = 0; end < s.length(); end++) {\n            char currentChar = s.charAt(end);\n            if (charIndexMap.containsKey(currentChar) && charIndexMap.get(currentChar) >= start) {\n                start = charIndexMap.get(currentChar) + 1;\n            }\n            charIndexMap.put(currentChar, end);\n            maxLength = Math.max(maxLength, end - start + 1);\n        }\n\n        return maxLength;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nYou are given a string and need to find the length of the longest substring without repeating characters.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers and Map:**\n   - Use a `Map` to track the last seen index of each character.\n   - Initialize `start` pointer at 0 and `maxLength` at 0.\n\n **Expand the Window:**\n   - Loop with `end` pointer over each character in the string.\n   - If the character is already in the map and its index is within the current window, update `start`.\n\n **Update Map and Max Length:**\n   - Update the character's latest index in the map.\n   - Calculate the current window length and update `maxLength` if it's larger.\n\n **Return Result:**\n   - After the loop, `maxLength` contains the length of the longest substring without repeating characters."
    }
  ]
},

{
  "slug": "4-median-of-two-sorted-arrays",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function findMedianSortedArrays(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n\n    let x = nums1.length;\n    let y = nums2.length;\n\n    let low = 0;\n    let high = x;\n\n    while (low <= high) {\n        let partitionX = Math.floor((low + high) / 2);\n        let partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n\n        let maxLeftX = (partitionX === 0) ? -Infinity : nums1[partitionX - 1];\n        let minRightX = (partitionX === x) ? Infinity : nums1[partitionX];\n\n        let maxLeftY = (partitionY === 0) ? -Infinity : nums2[partitionY - 1];\n        let minRightY = (partitionY === y) ? Infinity : nums2[partitionY];\n\n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }\n\n    throw new Error('Input arrays are not sorted properly');\n}",
      "explanation": "## 📝 Problem Recap\nGiven two sorted arrays `nums1` and `nums2`, find the median of the two sorted arrays.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Array Lengths:**\n   - `if (nums1.length > nums2.length)`\n   - Ensure `nums1` is the smaller array to minimize search space.\n\n **Initialize Variables:**\n   - `let x = nums1.length;`\n   - `let y = nums2.length;`\n   - `let low = 0;`\n   - `let high = x;`\n\n **Binary Search Loop:**\n   - `while (low <= high)`\n   - Perform binary search on the smaller array.\n\n **Calculate Partitions:**\n   - `let partitionX = Math.floor((low + high) / 2);`\n   - `let partitionY = Math.floor((x + y + 1) / 2) - partitionX;`\n   - These partitions divide the arrays into left and right halves.\n\n **Find Max/Min Values:**\n   - Use conditional checks to handle edge cases with empty partitions.\n   - `let maxLeftX = (partitionX === 0) ? -Infinity : nums1[partitionX - 1];`\n   - `let minRightX = (partitionX === x) ? Infinity : nums1[partitionX];`\n   - Similar for `maxLeftY` and `minRightY`.\n\n **Check Conditions for Median:**\n   - If both conditions hold: `maxLeftX <= minRightY && maxLeftY <= minRightX`, we have found the median.\n   - If total length is even, return average of max left and min right values.\n   - If odd, return the maximum of left values.\n\n **Adjust Search Range:**\n   - If `maxLeftX > minRightY`, move search range left: `high = partitionX - 1;`\n   - Otherwise, move right: `low = partitionX + 1;`\n\n **Error Handling:**\n   - If no valid partition found, throw an error indicating input arrays are not sorted properly.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```js\n      nums1 = [1, 3];\nnums2 = [2];\n```\n\n**Process:**\n- Initialize variables and perform binary search.\n- Calculate partitions and find max/min values.\n- Check conditions to find the median.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(log(min(m, n)))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Efficiently find median using binary search.\n- Handle edge cases with empty partitions.\n- Ensure input arrays are sorted."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        if len(nums1) > len(nums2):\n            return self.findMedianSortedArrays(nums2, nums1)\n\n        x = len(nums1)\n        y = len(nums2)\n\n        low = 0\n        high = x\n\n        while low <= high:\n            partitionX = (low + high) // 2\n            partitionY = (x + y + 1) // 2 - partitionX\n\n            maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]\n            minRightX = float('inf') if partitionX == x else nums1[partitionX]\n\n            maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]\n            minRightY = float('inf') if partitionY == y else nums2[partitionY]\n\n            if maxLeftX <= minRightY and maxLeftY <= minRightX:\n                if (x + y) % 2 == 0:\n                    return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n                else:\n                    return max(maxLeftX, maxLeftY)\n            elif maxLeftX > minRightY:\n                high = partitionX - 1\n            else:\n                low = partitionX + 1\n\n        raise ValueError('Input arrays are not sorted properly')",
      "explanation": "## 📝 Problem Recap\nGiven two sorted arrays `nums1` and `nums2`, find the median of the two sorted arrays.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Array Lengths:**\n   - `if len(nums1) > len(nums2):`\n   - Ensure `nums1` is the smaller array to minimize search space.\n\n **Initialize Variables:**\n   - `x = len(nums1)`\n   - `y = len(nums2)`\n   - `low = 0`\n   - `high = x`\n\n **Binary Search Loop:**\n   - `while low <= high:`\n   - Perform binary search on the smaller array.\n\n **Calculate Partitions:**\n   - `partitionX = (low + high) // 2`\n   - `partitionY = (x + y + 1) // 2 - partitionX`\n   - These partitions divide the arrays into left and right halves.\n\n **Find Max/Min Values:**\n   - Use conditional checks to handle edge cases with empty partitions.\n   - `maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]`\n   - `minRightX = float('inf') if partitionX == x else nums1[partitionX]`\n   - Similar for `maxLeftY` and `minRightY`.\n\n **Check Conditions for Median:**\n   - If both conditions hold: `maxLeftX <= minRightY and maxLeftY <= minRightX`, we have found the median.\n   - If total length is even, return average of max left and min right values.\n   - If odd, return the maximum of left values.\n\n **Adjust Search Range:**\n   - If `maxLeftX > minRightY`, move search range left: `high = partitionX - 1`\n   - Otherwise, move right: `low = partitionX + 1`\n\n **Error Handling:**\n   - If no valid partition found, raise a ValueError indicating input arrays are not sorted properly.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```python\nnums1 = [1, 3]\nnums2 = [2]\n```\n\n**Process:**\n- Initialize variables and perform binary search.\n- Calculate partitions and find max/min values.\n- Check conditions to find the median.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(log(min(m, n)))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Efficiently find median using binary search.\n- Handle edge cases with empty partitions.\n- Ensure input arrays are sorted."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n\n        int x = nums1.length;\n        int y = nums2.length;\n\n        int low = 0;\n        int high = x;\n\n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n\n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                if ((x + y) % 2 == 0) {\n                    return ((double)Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n                } else {\n                    return (double)Math.max(maxLeftX, maxLeftY);\n                }\n            } else if (maxLeftX > minRightY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n\n        throw new IllegalArgumentException(\"Input arrays are not sorted properly\");\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGiven two sorted arrays `nums1` and `nums2`, find the median of the two sorted arrays.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Array Lengths:**\n   - `if (nums1.length > nums2.length)`\n   - Ensure `nums1` is the smaller array to minimize search space.\n\n **Initialize Variables:**\n   - `int x = nums1.length;`\n   - `int y = nums2.length;`\n   - `int low = 0;`\n   - `int high = x;`\n\n **Binary Search Loop:**\n   - `while (low <= high)`\n   - Perform binary search on the smaller array.\n\n **Calculate Partitions:**\n   - `int partitionX = (low + high) / 2;`\n   - `int partitionY = (x + y + 1) / 2 - partitionX;`\n   - These partitions divide the arrays into left and right halves.\n\n **Find Max/Min Values:**\n   - Use conditional checks to handle edge cases with empty partitions.\n   - `int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];`\n   - `int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];`\n   - Similar for `maxLeftY` and `minRightY`.\n\n **Check Conditions for Median:**\n   - If both conditions hold: `maxLeftX <= minRightY && maxLeftY <= minRightX`, we have found the median.\n   - If total length is even, return average of max left and min right values.\n   - If odd, return the maximum of left values.\n\n **Adjust Search Range:**\n   - If `maxLeftX > minRightY`, move search range left: `high = partitionX - 1;`\n   - Otherwise, move right: `low = partitionX + 1;`\n\n **Error Handling:**\n   - If no valid partition found, throw an IllegalArgumentException indicating input arrays are not sorted properly.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```java\nint[] nums1 = {1, 3};\nint[] nums2 = {2};\n```\n\n**Process:**\n- Initialize variables and perform binary search.\n- Calculate partitions and find max/min values.\n- Check conditions to find the median.\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(log(min(m, n)))\n- **Space Complexity:** O(1)\n\n---\n\n## Key Takeaways\n- Efficiently find median using binary search.\n- Handle edge cases with empty partitions.\n- Ensure input arrays are sorted."
    }
  ]
}
,
{
  "slug": "5-longest-palindromic-substring",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function longestPalindrome(s) {\n    if (s.length < 2) return s;\n    let start = 0, end = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        const len1 = expandAroundCenter(s, i, i);\n        const len2 = expandAroundCenter(s, i, i + 1);\n        const len = Math.max(len1, len2);\n        if (len > end - start) {\n            start = i - Math.floor((len - 1) / 2);\n            end = i + Math.floor(len / 2);\n        }\n    }\n\n    return s.substring(start, end + 1);\n}\n\nfunction expandAroundCenter(s, left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n        left--;\n        right++;\n    }\n    return right - left - 1;\n}",
      "explanation": "## 📝 Problem Recap\nGiven a string `s`, find the longest palindromic substring in `s`.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Short Strings:**\n   - `if (s.length < 2) return s;`\n   - If the string is less than 2 characters, it is already a palindrome.\n\n **Initialize Variables:**\n   - `let start = 0, end = 0;`\n   - These will track the start and end indices of the longest palindrome found.\n\n **Loop Through Each Character:**\n   - `for (let i = 0; i < s.length; i++)`\n   - Iterate through each character in the string.\n\n **Expand Around Center:**\n   - `const len1 = expandAroundCenter(s, i, i);`\n   - Check for odd-length palindromes centered at `i`.\n   - `const len2 = expandAroundCenter(s, i, i + 1);`\n   - Check for even-length palindromes centered between `i` and `i + 1`.\n\n **Calculate Maximum Length:**\n   - `const len = Math.max(len1, len2);`\n   - Determine the maximum length of the palindrome found.\n\n **Update Start and End Indices:**\n   - If the new length is greater than the previous maximum, update `start` and `end` indices accordingly.\n\n **Return the Longest Palindrome:**\n   - `return s.substring(start, end + 1);`\n   - Extract and return the longest palindromic substring from the original string.\n\n---\n\n## Helper Function: Expand Around Center\n- This function checks for palindromes by expanding outwards from a center point.\n- It continues expanding as long as characters on both sides are equal."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) < 2:\n            return s\n        start, end = 0, 0\n\n        for i in range(len(s)):\n            len1 = self.expandAroundCenter(s, i, i)\n            len2 = self.expandAroundCenter(s, i, i + 1)\n            length = max(len1, len2)\n            if length > end - start:\n                start = i - (length - 1) // 2\n                end = i + length // 2\n\n        return s[start:end + 1]\n\n    def expandAroundCenter(self, s: str, left: int, right: int) -> int:\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1",
      "explanation": "## 📝 Problem Recap\nGiven a string `s`, find the longest palindromic substring in `s`.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Short Strings:**\n   - `if len(s) < 2:`\n   - If the string is less than 2 characters, it is already a palindrome.\n\n **Initialize Variables:**\n   - `start, end = 0, 0`\n   - These will track the start and end indices of the longest palindrome found.\n\n **Loop Through Each Character:**\n   - `for i in range(len(s)):`\n   - Iterate through each character in the string.\n\n **Expand Around Center:**\n   - `len1 = self.expandAroundCenter(s, i, i)`\n   - Check for odd-length palindromes centered at `i`.\n   - `len2 = self.expandAroundCenter(s, i, i + 1)`\n   - Check for even-length palindromes centered between `i` and `i + 1`.\n\n **Calculate Maximum Length:**\n   - `length = max(len1, len2)`\n   - Determine the maximum length of the palindrome found.\n\n **Update Start and End Indices:**\n   - If the new length is greater than the previous maximum, update `start` and `end` indices accordingly.\n\n **Return the Longest Palindrome:**\n   - `return s[start:end + 1]`\n   - Extract and return the longest palindromic substring from the original string.\n\n---\n\n## Helper Function: Expand Around Center\n- This function checks for palindromes by expanding outwards from a center point.\n- It continues expanding as long as characters on both sides are equal."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public String longestPalindrome(String s) {\n        if (s.length() < 2) return s;\n        int start = 0, end = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            int len1 = expandAroundCenter(s, i, i);\n            int len2 = expandAroundCenter(s, i, i + 1);\n            int length = Math.max(len1, len2);\n            if (length > end - start) {\n                start = i - (length - 1) / 2;\n                end = i + length / 2;\n            }\n        }\n\n        return s.substring(start, end + 1);\n    }\n\n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGiven a string `s`, find the longest palindromic substring in `s`.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Short Strings:**\n   - `if (s.length() < 2) return s;`\n   - If the string is less than 2 characters, it is already a palindrome.\n\n **Initialize Variables:**\n   - `int start = 0, end = 0;`\n   - These will track the start and end indices of the longest palindrome found.\n\n **Loop Through Each Character:**\n   - `for (int i = 0; i < s.length(); i++)`\n   - Iterate through each character in the string.\n\n **Expand Around Center:**\n   - `int len1 = expandAroundCenter(s, i, i);`\n   - Check for odd-length palindromes centered at `i`.\n   - `int len2 = expandAroundCenter(s, i, i + 1);`\n   - Check for even-length palindromes centered between `i` and `i + 1`.\n\n **Calculate Maximum Length:**\n   - `int length = Math.max(len1, len2);`\n   - Determine the maximum length of the palindrome found.\n\n **Update Start and End Indices:**\n   - If the new length is greater than the previous maximum, update `start` and `end` indices accordingly.\n\n **Return the Longest Palindrome:**\n   - `return s.substring(start, end + 1);`\n   - Extract and return the longest palindromic substring from the original string.\n\n---\n\n## Helper Function: Expand Around Center\n- This function checks for palindromes by expanding outwards from a center point.\n- It continues expanding as long as characters on both sides are equal."
    }
  ]
},
{
  "slug": "6-zigzag-conversion",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function convert(s, numRows) {\n    if (numRows === 1 || numRows >= s.length) return s;\n    const rows = Array.from({ length: numRows }, () => '');\n    let currentRow = 0;\n    let goingDown = false;\n\n    for (let char of s) {\n        rows[currentRow] += char;\n        if (currentRow === 0) goingDown = true;\n        else if (currentRow === numRows - 1) goingDown = false;\n        currentRow += goingDown ? 1 : -1;\n    }\n\n    return rows.join('');\n}",
      "explanation": "## 📝 Problem Recap\nConvert a string `s` into a zigzag pattern on a given number of rows and then read it line by line.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Edge Cases:**\n   - `if (numRows === 1 || numRows >= s.length) return s;`\n   - If there is only one row or the number of rows is greater than or equal to the length of the string, return the string as s.\n\n **Initialize Rows:**\n   - `const rows = Array.from({ length: numRows }, () => '');`\n   - Create an array to hold each row of the zigzag pattern.\n\n **Initialize Variables:**\n   - `let currentRow = 0;` to track the current row.\n   - `let goingDown = false;` to determine the direction of traversal.\n\n **Loop Through Each Character:**\n   - `for (let char of s)` iterates through each character in the string.\n   - Append the character to the current row: `rows[currentRow] += char;`\n   - Update direction: If at the top row, set `goingDown` to true; if at the bottom row, set it to false.\n   - Adjust `currentRow` based on the direction.\n\n **Join Rows:**\n   - `return rows.join('');`\n   - Concatenate all rows into a single string and return it."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n        rows = [''] * numRows\n        currentRow = 0\n        goingDown = False\n\n        for char in s:\n            rows[currentRow] += char\n            if currentRow == 0:\n                goingDown = True\n            elif currentRow == numRows - 1:\n                goingDown = False\n            currentRow += 1 if goingDown else -1\n\n        return ''.join(rows)", 
      "explanation": "## 📝 Problem Recap\nConvert a string `s` into a zigzag pattern on a given number of rows and then read it line by line.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Edge Cases:**\n   - `if numRows == 1 or numRows >= len(s):`\n   - If there is only one row or the number of rows is greater than or equal to the length of the string, return the string as is.\n\n **Initialize Rows:**\n   - `rows = [''] * numRows`\n   - Create a list to hold each row of the zigzag pattern.\n\n **Initialize Variables:**\n   - `currentRow = 0` to track the current row.\n   - `goingDown = False` to determine the direction of traversal.\n\n **Loop Through Each Character:**\n   - `for char in s:` iterates through each character in the string.\n   - Append the character to the current row: `rows[currentRow] += char`\n   - Update direction: If at the top row, set `goingDown` to True; if at the bottom row, set it to False.\n   - Adjust `currentRow` based on the direction.\n\n **Join Rows:**\n   - `return ''.join(rows)`\n   - Concatenate all rows into a single string and return it."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public String convert(String s, int numRows) {\n        if (numRows == 1 || numRows >= s.length()) return s;\n        StringBuilder[] rows = new StringBuilder[numRows];\n        for (int i = 0; i < numRows; i++) {\n            rows[i] = new StringBuilder();\n        }\n        int currentRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows[currentRow].append(c);\n            if (currentRow == 0) goingDown = true;\n            else if (currentRow == numRows - 1) goingDown = false;\n            currentRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) {\n            result.append(row);\n        }\n        return result.toString();\n    }\n}",
      "explanation": "## 📝 Problem Recap\nConvert a string `s` into a zigzag pattern on a given number of rows and then read it line by line.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Edge Cases:**\n   - `if numRows == 1 or numRows >= len(s):`\n   - If there is only one row or the number of rows is greater than or equal to the length of the string, return the string as is.\n\n **Initialize Rows:**\n   - `rows = [''] * numRows`\n   - Create a list to hold each row of the zigzag pattern.\n\n **Initialize Variables:**\n   - `currentRow = 0` to track the current row.\n   - `goingDown = False` to determine the direction of traversal.\n\n **Loop Through Each Character:**\n   - `for char in s:` iterates through each character in the string.\n   - Append the character to the current row: `rows[currentRow] += char`\n   - Update direction: If at the top row, set `goingDown` to True; if at the bottom row, set it to False.\n   - Adjust `currentRow` based on the direction.\n\n **Join Rows:**\n   - `return ''.join(rows)`\n   - Concatenate all rows into a single string and return it."
    }
  ]
  },

{
  "slug": "7-reverse-integer",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function reverse(x) {\n    const sign = x < 0 ? -1 : 1;\n    const reversed = parseInt(Math.abs(x).toString().split('').reverse().join('')) * sign;\n    return (reversed < Math.pow(-2, 31) || reversed > Math.pow(2, 31) - 1) ? 0 : reversed;\n}",
      "explanation": "## 📝 Problem Recap\nGiven a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range, return `0`.\n\n---\n\n## Step-by-Step Explanation\n\n **Determine Sign:**\n   - `const sign = x < 0 ? -1 : 1;`\n   - Store the sign of the number to apply it later.\n\n **Reverse Digits:**\n   - `const reversed = parseInt(Math.abs(x).toString().split('').reverse().join('')) * sign;`\n   - Convert the absolute value of `x` to a string, split it into characters, reverse the array, join it back into a string, and convert it back to an integer.\n   - Multiply by the sign to restore the original sign.\n\n **Check for Overflow:**\n   - `return (reversed < Math.pow(-2, 31) || reversed > Math.pow(2, 31) - 1) ? 0 : reversed;`\n   - If the reversed number is outside the signed 32-bit integer range, return `0`. Otherwise, return the reversed number."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def reverse(self, x: int) -> int:\n        sign = -1 if x < 0 else 1\n        reversed_num = int(str(abs(x))[::-1]) * sign\n        if reversed_num < -2**31 or reversed_num > 2**31 - 1:\n            return 0\n        return reversed_num",
      "explanation": "## 📝 Problem Recap\nGiven a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range, return `0`.\n\n---\n\n## Step-by-Step Explanation\n\n **Determine Sign:**\n   - `sign = -1 if x < 0 else 1`\n   - Store the sign of the number to apply it later.\n\n **Reverse Digits:**\n   - `reversed_num = int(str(abs(x))[::-1]) * sign`\n   - Convert the absolute value of `x` to a string, reverse it, and convert it back to an integer.\n   - Multiply by the sign to restore the original sign.\n\n **Check for Overflow:**\n   - `if reversed_num < -2**31 or reversed_num > 2**31 - 1:`\n   - If the reversed number is outside the signed 32-bit integer range, return `0`.\n   - `return 0`\n   - Otherwise, return the reversed number."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int reverse(int x) {\n        int sign = (x < 0) ? -1 : 1;\n        long reversed = Long.parseLong(new StringBuilder(String.valueOf(Math.abs(x))).reverse().toString()) * sign;\n        if (reversed < Integer.MIN_VALUE || reversed > Integer.MAX_VALUE) {\n            return 0;\n        }\n        return (int) reversed;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGiven a signed 32-bit integer `x`, return `x` with its digits reversed. If reversing `x` causes the value to go outside the signed 32-bit integer range, return `0`.\n\n---\n\n## Step-by-Step Explanation\n\n **Determine Sign:**\n   - `int sign = (x < 0) ? -1 : 1;`\n   - Store the sign of the number to apply it later.\n\n **Reverse Digits:**\n   - `long reversed = Long.parseLong(new StringBuilder(String.valueOf(Math.abs(x))).reverse().toString()) * sign;`\n   - Convert the absolute value of `x` to a string, reverse it using `StringBuilder`, and convert it back to a long.\n   - Multiply by the sign to restore the original sign.\n\n **Check for Overflow:**\n   - `if (reversed < Integer.MIN_VALUE || reversed > Integer.MAX_VALUE)`\n   - If the reversed number is outside the signed 32-bit integer range, return `0`.\n   - `return 0`\n   - Otherwise, return the reversed number as an integer."
    }
  ]
},
{
  "slug": "8-string-to-integer-atoi",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function myAtoi(s) {\n    s = s.trim();\n    if (s.length === 0) return 0;\n\n    let sign = 1;\n    let index = 0;\n\n    if (s[index] === '-' || s[index] === '+') {\n        sign = s[index] === '-' ? -1 : 1;\n        index++;\n    }\n\n    let result = 0;\n    while (index < s.length && s[index] >= '0' && s[index] <= '9') {\n        result = result * 10 + (s[index] - '0');\n        index++;\n    }\n\n    result *= sign;\n\n    const INT_MAX = Math.pow(2, 31) - 1;\n    const INT_MIN = -Math.pow(2, 31);\n\n    if (result > INT_MAX) return INT_MAX;\n    if (result < INT_MIN) return INT_MIN;\n\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nConvert a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\n---\n\n## Step-by-Step Explanation\n\n **Trim Whitespace:**\n   - `s = s.trim();`\n   - Remove leading and trailing whitespace from the string.\n\n **Check for Empty String:**\n   - `if (s.length === 0) return 0;`\n   - If the string is empty after trimming, return `0`.\n\n **Determine Sign:**\n   - Initialize `sign` to `1`.\n   - Check if the first character is a sign (`-` or `+`). If it is, update the `sign` variable and increment the index.\n\n **Initialize Result:**\n   - `let result = 0;`\n   - This will hold the final integer value.\n\n **Convert Characters to Integer:**\n   - Loop through the string while the current character is a digit (`0-9`). For each digit, update the `result` by multiplying it by `10` and adding the current digit's value.\n\n **Apply Bounds:**\n   - Clamp the result to the 32-bit signed integer range.\n   - `if (result > INT_MAX) return INT_MAX;`\n   - `if (result < INT_MIN) return INT_MIN;`\n\n    return result;\n}"
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        s = s.strip()\n        if not s:\n            return 0\n\n        sign = 1\n        index = 0\n\n        if s[index] == '-' or s[index] == '+':\n            sign = -1 if s[index] == '-' else 1\n            index += 1\n\n        result = 0\n        while index < len(s) and '0' <= s[index] <= '9':\n            result = result * 10 + (ord(s[index]) - ord('0'))\n            index += 1\n\n        result *= sign\n\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n\n        if result > INT_MAX:\n            return INT_MAX\n        if result < INT_MIN:\n            return INT_MIN\n\n        return result",
      "explanation": "## 📝 Problem Recap\nConvert a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\n---\n\n## Step-by-Step Explanation\n\n **Trim Whitespace:**\n   - `s = s.strip()`\n   - Remove leading and trailing whitespace from the string.\n\n **Check for Empty String:**\n   - `if not s:`\n   - If the string is empty after trimming, return `0`.\n\n **Determine Sign:**\n   - Initialize `sign` to `1`.\n   - Check if the first character is a sign (`-` or `+`). If it is, update the `sign` variable and increment the index.\n\n **Initialize Result:**\n   - `result = 0`\n   - This will hold the final integer value.\n\n **Convert Characters to Integer:**\n   - Loop through the string while the current character is a digit (`0-9`). For each digit, update the `result` by multiplying it by `10` and adding the current digit's value using `ord()` to convert characters to integers.\n\n **Apply Bounds:**\n   - Clamp the result to the 32-bit signed integer range.\n   - `if result > INT_MAX:` return INT_MAX\n   - `if result < INT_MIN:` return INT_MIN\n\n        return result;\n}"
    },
  {
      "language": "Java",
      "code": "public class Solution {\n    public int myAtoi(String s) {\n        s = s.trim();\n        if (s.length() == 0) return 0;\n\n        int sign = 1;\n        int index = 0;\n\n        if (s.charAt(index) == '-' || s.charAt(index) == '+') {\n            sign = (s.charAt(index) == '-') ? -1 : 1;\n            index++;\n        }\n\n        long result = 0;\n        while (index < s.length() && Character.isDigit(s.charAt(index))) {\n            result = result * 10 + (s.charAt(index) - '0');\n            index++;\n        }\n\n        result *= sign;\n\n        int INT_MAX = Integer.MAX_VALUE;\n        int INT_MIN = Integer.MIN_VALUE;\n\n        if (result > INT_MAX) return INT_MAX;\n        if (result < INT_MIN) return INT_MIN;\n\n        return (int) result;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nConvert a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\n---\n\n## Step-by-Step Explanation\n\n **Trim Whitespace:**\n   - `s = s.trim();`\n   - Remove leading and trailing whitespace from the string.\n\n **Check for Empty String:**\n   - `if (s.length() == 0) return 0;`\n   - If the string is empty after trimming, return `0`.\n\n **Determine Sign:**\n   - Initialize `sign` to `1`.\n   - Check if the first character is a sign (`-` or `+`). If it is, update the `sign` variable and increment the index.\n\n **Initialize Result:**\n   - `long result = 0;`\n   - This will hold the final integer value.\n\n **Convert Characters to Integer:**\n   - Loop through the string while the current character is a digit (`0-9`). For each digit, update the `result` by multiplying it by `10` and adding the current digit's value.\n\n **Apply Bounds:**\n   - Clamp the result to the 32-bit signed integer range.\n   - `if (result > INT_MAX) return INT_MAX;`\n   - `if (result < INT_MIN) return INT_MIN;`\n\n        return result;\n}"
    }
  ]
  },
{
  "slug": "9-palindrome-number",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function isPalindrome(x) {\n    if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n\n    let reversedHalf = 0;\n    while (x > reversedHalf) {\n        reversedHalf = reversedHalf * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n\n    return x === reversedHalf || x === Math.floor(reversedHalf / 10);\n}",
      "explanation": "## 📝 Problem Recap\nDetermine if an integer `x` is a palindrome **without converting it to a string**.\n\n---\n\n## Step-by-Step Explanation\n\n **Step 1: Eliminate Obvious Non-Palindromes**\n   - Negative numbers are not palindromes.\n   - If the number ends with 0 but is not 0 itself, it can't be a palindrome.\n\n **Step 2: Reverse Half the Number**\n   - Initialize `reversedHalf = 0`.\n   - While the original number is greater than the reversed half:\n     - Pop the last digit from `x` and push it to `reversedHalf`.\n\n **Step 3: Check for Palindrome**\n   - If the number has an even number of digits, `x` should equal `reversedHalf`.\n   - If the number has an odd number of digits, we can remove the middle digit from `reversedHalf` using `Math.floor(reversedHalf / 10)` and then compare.\n\n **Step 4: Return the Result**\n   - If either condition is true, return `true`.\n   - Else, return `false`.\n\n---\n\n## Pseudocode\n```\nIf x < 0 or (x ends with 0 and x is not 0)\n    return false\n\nInitialize reversedHalf = 0\n\nWhile x > reversedHalf\n    reversedHalf = reversedHalf * 10 + last digit of x\n    x = remove last digit from x\n\nReturn true if x == reversedHalf or x == Math.floor(reversedHalf / 10)\n```\n\n---\n\n## Complexity Analysis\n- **Time Complexity:** O(log₁₀(N)) because we process half of the digits.\n- **Space Complexity:** O(1) as no extra space is used."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reversed_half = 0\n        while x > reversed_half:\n            reversed_half = reversed_half * 10 + x % 10\n            x //= 10\n\n        return x == reversed_half or x == reversed_half // 10",
      "explanation": "## 📝 Problem Recap\nDetermine if an integer `x` is a palindrome **without converting it to a string**.\n\n---\n\n## Step-by-Step Explanation\n\n **Step 1: Eliminate Obvious Non-Palindromes**\n   - Negative numbers are not palindromes.\n   - If the number ends with 0 but is not 0 itself, it can't be a palindrome.\n\n **Step 2: Reverse Half the Number**\n   - Initialize `reversed_half = 0`.\n   - While the original number is greater than the reversed half:\n     - Pop the last digit from `x` and push it to `reversed_half`.\n\n **Step 3: Check for Palindrome**\n   - If the number has an even number of digits, `x` should equal `reversed_half`.\n   - If the number has an odd number of digits, we can remove the middle digit from `reversed_half` using `reversed_half // 10` and then compare.\n\n **Step 4: Return the Result**\n   - If either condition is true, return `True`.\n   - Else, return `False`.\n\n---\n\n## Pseudocode\n```\nIf x < 0 or (x ends with 0 and x is not 0)\n    return False\n\nInitialize reversed_half = 0\n\nWhile x > reversed_half\n    reversed_half = reversed_half * 10 + last digit of x\n    x = remove last digit from x\n\nReturn True if x == reversed_half or x == reversed_half // 10\n```\n\n---\n\n## Complexity Analysis\n- **Time Complexity:** O(log₁₀(N)) because we process half of the digits.\n- **Space Complexity:** O(1) as no extra space is used."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public boolean isPalindrome(int x) {\n        if (x < 0 || (x % 10 == 0 && x != 0)) return false;\n\n        int reversedHalf = 0;\n        while (x > reversedHalf) {\n            reversedHalf = reversedHalf * 10 + x % 10;\n            x /= 10;\n        }\n\n        return x == reversedHalf || x == reversedHalf / 10;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nDetermine if an integer `x` is a palindrome **without converting it to a string**.\n\n---\n\n## Step-by-Step Explanation\n\n **Step 1: Eliminate Obvious Non-Palindromes**\n   - Negative numbers are not palindromes.\n   - If the number ends with 0 but is not 0 itself, it can't be a palindrome.\n\n **Step 2: Reverse Half the Number**\n   - Initialize `reversedHalf = 0`.\n   - While the original number is greater than the reversed half:\n     - Pop the last digit from `x` and push it to `reversedHalf`.\n\n **Step 3: Check for Palindrome**\n   - If the number has an even number of digits, `x` should equal `reversedHalf`.\n   - If the number has an odd number of digits, we can remove the middle digit from `reversedHalf` using `reversedHalf / 10` and then compare.\n\n **Step 4: Return the Result**\n   - If either condition is true, return `true`.\n   - Else, return `false`.\n\n---\n\n## Pseudocode\n```\nIf x < 0 or (x ends with 0 and x is not 0)\n    return false\n\nInitialize reversedHalf = 0\n\nWhile x > reversedHalf\n    reversedHalf = reversedHalf * 10 + last digit of x\n    x = remove last digit from x\n\nReturn true if x == reversedHalf or x == reversedHalf / 10\n```\n\n---\n\n## Complexity Analysis\n- **Time Complexity:** O(log₁₀(N)) because we process half of the digits.\n- **Space Complexity:** O(1) as no extra space is used."
    }
  ]
},

  {
  "slug": "10-regular-expression-matching",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function isMatch(s, p) {\n    const dp = Array.from({ length: s.length + 1 }, () => Array(p.length + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= p.length; j++) {\n        if (p[j - 1] === '*') {\n            dp[0][j] = dp[0][j - 2];\n        }\n    }\n\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 1; j <= p.length; j++) {\n            if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] === '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.')));\n            }\n        }\n    }\n\n    return dp[s.length][p.length];\n}",
      "explanation": "## 📝 Problem Recap\nImplement regular expression matching with support for `.` and `*`.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize DP Table:**\n   - Create a DP table `dp` of size `(s.length + 1) x (p.length + 1)` initialized to `false`.\n   - `dp[0][0] = true` indicates that an empty string matches an empty pattern.\n\n **Handle Patterns with `*`:**\n   - Loop through the pattern `p` and set `dp[0][j]` to `true` if the pattern can match an empty string.\n   - This is done by checking if the character before `*` can match zero occurrences.\n\n **Fill the DP Table:**\n   - Loop through each character in the string `s` and pattern `p`.\n   - If characters match or the pattern character is `.`, set `dp[i][j]` based on the previous state `dp[i - 1][j - 1]`.\n   - If the pattern character is `*`, check two cases:\n     - Match zero occurrences: `dp[i][j - 2]`\n     - Match one or more occurrences: `dp[i - 1][j]` if the previous character matches.\n\n **Return Result:**\n   - The result is found in `dp[s.length][p.length]`, indicating if the entire string matches the entire pattern."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = True\n\n        for j in range(1, len(p) + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 2]\n\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(p) + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n        return dp[len(s)][len(p)]",
      "explanation": "## 📝 Problem Recap\nImplement regular expression matching with support for `.` and `*`.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize DP Table:**\n   - Create a DP table `dp` of size `(len(s) + 1) x (len(p) + 1)` initialized to `False`.\n   - `dp[0][0] = True` indicates that an empty string matches an empty pattern.\n\n **Handle Patterns with `*`:**\n   - Loop through the pattern `p` and set `dp[0][j]` to `True` if the pattern can match an empty string.\n   - This is done by checking if the character before `*` can match zero occurrences.\n\n **Fill the DP Table:**\n   - Loop through each character in the string `s` and pattern `p`.\n   - If characters match or the pattern character is `.`, set `dp[i][j]` based on the previous state `dp[i - 1][j - 1]`.\n   - If the pattern character is `*`, check two cases:\n     - Match zero occurrences: `dp[i][j - 2]`\n     - Match one or more occurrences: `dp[i - 1][j]` if the previous character matches.\n\n **Return Result:**\n   - The result is found in `dp[s.length][p.length]`, indicating if the entire string matches the entire pattern."
    
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public boolean isMatch(String s, String p) {\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\n        dp[0][0] = true;\n\n        for (int j = 1; j <= p.length(); j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 1; j <= p.length(); j++) {\n                if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')));\n                }\n            }\n        }\n\n        return dp[s.length()][p.length()];\n    }\n}",
      "explanation": "## 📝 Problem Recap\nImplement regular expression matching with support for `.` and `*`.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize DP Table:**\n   - Create a DP table `dp` of size `(s.length() + 1) x (p.length() + 1)` initialized to `false`.\n   - `dp[0][0] = true` indicates that an empty string matches an empty pattern.\n\n **Handle Patterns with `*`:**\n   - Loop through the pattern `p` and set `dp[0][j]` to `true` if the pattern can match an empty string.\n   - This is done by checking if the character before `*` can match zero occurrences.\n\n **Fill the DP Table:**\n   - Loop through each character in the string `s` and pattern `p`.\n   - If characters match or the pattern character is `.`, set `dp[i][j]` based on the previous state `dp[i - 1][j - 1]`.\n   - If the pattern character is `*`, check two cases:\n     - Match zero occurrences: `dp[i][j - 2]`\n     - Match one or more occurrences: `dp[i - 1][j]` if the previous character matches.\n\n **Return Result:**\n   - The result is found in `dp[s.length()][p.length()]`, indicating if the entire string matches the entire pattern."
    }
  ]
  },
  {
  "slug": "11-container-with-most-water",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function maxArea(height) {\n    let left = 0, right = height.length - 1;\n    let maxArea = 0;\n\n    while (left < right) {\n        const width = right - left;\n        const currentHeight = Math.min(height[left], height[right]);\n        const area = width * currentHeight;\n        maxArea = Math.max(maxArea, area);\n\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return maxArea;\n}",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers representing the heights of vertical lines, find two lines that together with the x-axis form a container that holds the most water.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - `let left = 0, right = height.length - 1;`\n   - Start with two pointers at the beginning and end of the array.\n\n **Initialize Max Area:**\n   - `let maxArea = 0;`\n   - This will hold the maximum area found.\n\n **Loop Until Pointers Meet:**\n   - While `left < right`, calculate the area formed by the lines at the `left` and `right` pointers.\n   - Calculate width as `right - left` and height as the minimum of the two heights.\n   - Update `maxArea` if the current area is larger.\n\n **Move Pointers:**\n   - If the height at `left` is less than the height at `right`, increment `left` to potentially find a taller line.\n   - Otherwise, decrement `right`.\n\n **Return Max Area:**\n   - After the loop ends, return `maxArea`."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        left, right = 0, len(height) - 1\n        max_area = 0\n\n        while left < right:\n            width = right - left\n            current_height = min(height[left], height[right])\n            area = width * current_height\n            max_area = max(max_area, area)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_area",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers representing the heights of vertical lines, find two lines that together with the x-axis form a container that holds the most water.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - `left, right = 0, len(height) - 1`\n   - Start with two pointers at the beginning and end of the array.\n\n **Initialize Max Area:**\n   - `max_area = 0`\n   - This will hold the maximum area found.\n\n **Loop Until Pointers Meet:**\n   - While `left < right`, calculate the area formed by the lines at the `left` and `right` pointers.\n   - Calculate width as `right - left` and height as the minimum of the two heights.\n   - Update `max_area` if the current area is larger.\n\n **Move Pointers:**\n   - If the height at `left` is less than the height at `right`, increment `left` to potentially find a taller line.\n   - Otherwise, decrement `right`.\n\n **Return Max Area:**\n   - After the loop ends, return `max_area`."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int maxArea(int[] height) {\n        int left = 0, right = height.length - 1;\n        int maxArea = 0;\n\n        while (left < right) {\n            int width = right - left;\n            int currentHeight = Math.min(height[left], height[right]);\n            int area = width * currentHeight;\n            maxArea = Math.max(maxArea, area);\n\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return maxArea;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers representing the heights of vertical lines, find two lines that together with the x-axis form a container that holds the most water.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - `int left = 0, right = height.length - 1;`\n   - Start with two pointers at the beginning and end of the array.\n\n **Initialize Max Area:**\n   - `int maxArea = 0;`\n   - This will hold the maximum area found.\n\n **Loop Until Pointers Meet:**\n   - While `left < right`, calculate the area formed by the lines at the `left` and `right` pointers.\n   - Calculate width as `right - left` and height as the minimum of the two heights.\n   - Update `maxArea` if the current area is larger.\n\n **Move Pointers:**\n   - If the height at `left` is less than the height at `right`, increment `left` to potentially find a taller line.\n   - Otherwise, decrement `right`.\n\n **Return Max Area:**\n   - After the loop ends, return `maxArea`."
    }
  ]
  },
  {
  "slug": "12-integer-to-roman",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function intToRoman(num) {\n    const val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    const syms = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];\n    let roman = '';\n\n    for (let i = 0; i < val.length; i++) {\n        while (num >= val[i]) {\n            roman += syms[i];\n            num -= val[i];\n        }\n    }\n\n    return roman;\n}",
      "explanation": "## 📝 Problem Recap\nConvert an integer to a Roman numeral.\n\n---\n\n## Step-by-Step Explanation\n\n **Define Values and Symbols:**\n   - Create two arrays: `val` for integer values and `syms` for corresponding Roman symbols.\n\n **Initialize Result String:**\n   - `let roman = '';`\n   - This will hold the resulting Roman numeral.\n\n **Loop Through Values:**\n   - For each value in `val`, check if the number is greater than or equal to that value.\n   - If it is, append the corresponding symbol to `roman` and subtract the value from `num` until `num` is less than the value.\n\n **Return Result:**\n   - After processing all values, return the resulting Roman numeral string."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def intToRoman(self, num: int) -> str:\n        val = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n        syms = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n        roman = ''\n\n        for i in range(len(val)):\n            while num >= val[i]:\n                roman += syms[i]\n                num -= val[i]\n\n        return roman",
      "explanation": "## 📝 Problem Recap\nConvert an integer to a Roman numeral.\n\n---\n\n## Step-by-Step Explanation\n\n **Define Values and Symbols:**\n   - Create two lists: `val` for integer values and `syms` for corresponding Roman symbols.\n\n **Initialize Result String:**\n   - `roman = ''`\n   - This will hold the resulting Roman numeral.\n\n **Loop Through Values:**\n   - For each value in `val`, check if the number is greater than or equal to that value.\n   - If it is, append the corresponding symbol to `roman` and subtract the value from `num` until `num` is less than the value.\n\n **Return Result:**\n   - After processing all values, return the resulting Roman numeral string."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public String intToRoman(int num) {\n        int[] val = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] syms = {'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'};\n        StringBuilder roman = new StringBuilder();\n\n        for (int i = 0; i < val.length; i++) {\n            while (num >= val[i]) {\n                roman.append(syms[i]);\n                num -= val[i];\n            }\n        }\n\n        return roman.toString();\n    }\n}",
      "explanation": "## 📝 Problem Recap\nConvert an integer to a Roman numeral.\n\n---\n\n## Step-by-Step Explanation\n\n **Define Values and Symbols:**\n   - Create two arrays: `val` for integer values and `syms` for corresponding Roman symbols.\n\n **Initialize Result String:**\n   - Use `StringBuilder` to efficiently build the resulting Roman numeral string.\n\n **Loop Through Values:**\n   - For each value in `val`, check if the number is greater than or equal to that value.\n   - If it is, append the corresponding symbol to `roman` and subtract the value from `num` until `num` is less than the value.\n\n **Return Result:**\n   - After processing all values, return the resulting Roman numeral string."
    }
  ]
  },
  {
  "slug": "13-roman-to-integer",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function romanToInt(s) {\n    const romanMap = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    };\n    let total = 0;\n    let prevValue = 0;\n\n    for (let i = s.length - 1; i >= 0; i--) {\n        const currentValue = romanMap[s[i]];\n        if (currentValue < prevValue) {\n            total -= currentValue;\n        } else {\n            total += currentValue;\n        }\n        prevValue = currentValue;\n    }\n\n    return total;\n}",
      "explanation": "## 📝 Problem Recap\nConvert a Roman numeral string to an integer.\n\n---\n\n## Step-by-Step Explanation\n\n **Define Roman Map:**\n   - Create a map `romanMap` that maps Roman numeral characters to their integer values.\n\n **Initialize Total and Previous Value:**\n   - `let total = 0;`\n   - `let prevValue = 0;`\n   - These will hold the cumulative total and the value of the previous Roman numeral character.\n\n **Iterate Through the String in Reverse:**\n   - Loop through the string from the end to the beginning.\n   - For each character, get its integer value from `romanMap`.\n   - If the current value is less than the previous value, subtract it from `total` (indicating a subtractive notation).\n   - Otherwise, add it to `total`.\n   - Update `prevValue` to the current value.\n\n **Return Total:**\n   - After processing all characters, return the total."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def romanToInt(self, s: str) -> int:\n        roman_map = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500,\n        'M': 1000}\n        total = 0\n        prev_value = 0\n\n        for char in reversed(s):\n            current_value = roman_map[char]\n            if current_value < prev_value:\n                total -= current_value\n            else:\n                total += current_value\n            prev_value = current_value\n\n        return total",
      "explanation": "## 📝 Problem Recap\nConvert a Roman numeral string to an integer.\n\n---\n\n## Step-by-Step Explanation\n\n **Define Roman Map:**\n   - Create a dictionary `roman_map` that maps Roman numeral characters to their integer values.\n\n **Initialize Total and Previous Value:**\n   - `total = 0`\n   - `prev_value = 0`\n   - These will hold the cumulative total and the value of the previous Roman numeral character.\n\n **Iterate Through the String in Reverse:**\n   - Loop through the string from the end to the beginning.\n   - For each character, get its integer value from `roman_map`.\n   - If the current value is less than the previous value, subtract it from `total` (indicating a subtractive notation).\n   - Otherwise, add it to `total`.\n   - Update `prev_value` to the current value.\n\n **Return Total:**\n   - After processing all characters, return the total."
    }
  ]
},
{
  "slug": "14-longest-common-prefix",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function longestCommonPrefix(strs) {\n    if (strs.length === 0) return '';\n    let prefix = strs[0];\n\n    for (let i = 1; i < strs.length; i++) {\n        while (strs[i].indexOf(prefix) !== 0) {\n            prefix = prefix.slice(0, -1);\n            if (prefix === '') return '';\n        }\n    }\n\n    return prefix;\n}",
      "explanation": "## 📝 Problem Recap\nFind the longest common prefix string among an array of strings.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Empty Array:**\n   - If the input array `strs` is empty, return an empty string.\n\n **Initialize Prefix:**\n   - Start with the first string as the initial prefix.\n\n **Iterate Through Strings:**\n   - For each subsequent string, check if it starts with the current prefix.\n   - If it does not, reduce the prefix by removing the last character until a match is found or the prefix becomes empty.\n\n **Return Prefix:**\n   - After checking all strings, return the longest common prefix."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return ''\n        prefix = strs[0]\n\n        for i in range(1, len(strs)):\n            while strs[i].find(prefix) != 0:\n                prefix = prefix[:-1]\n                if not prefix:\n                    return ''\n\n        return prefix",
      "explanation": "## 📝 Problem Recap\nFind the longest common prefix string among an array of strings.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Empty Array:**\n   - If the input list `strs` is empty, return an empty string.\n\n **Initialize Prefix:**\n   - Start with the first string as the initial prefix.\n\n **Iterate Through Strings:**\n   - For each subsequent string, check if it starts with the current prefix.\n   - If it does not, reduce the prefix by removing the last character until a match is found or the prefix becomes empty.\n\n **Return Prefix:**\n   - After checking all strings, return the longest common prefix."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) return \"\";\n        String prefix = strs[0];\n\n        for (int i = 1; i < strs.length; i++) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.isEmpty()) return \"\";\n            }\n        }\n\n        return prefix;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind the longest common prefix string among an array of strings.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Empty Array:**\n   - If the input array `strs` is empty, return an empty string.\n\n **Initialize Prefix:**\n   - Start with the first string as the initial prefix.\n\n **Iterate Through Strings:**\n   - For each subsequent string, check if it starts with the current prefix.\n   - If it does not, reduce the prefix by removing the last character until a match is found or the prefix becomes empty.\n\n **Return Prefix:**\n   - After checking all strings, return the longest common prefix."
    }
  ]
},
{
  "slug": "15-3sum",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        let left = i + 1, right = nums.length - 1;\n\n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            if (sum < 0) {\n                left++;\n            } else if (sum > 0) {\n                right--;\n            } else {\n                result.push([nums[i], nums[left], nums[right]]);\n                while (left < right && nums[left] === nums[left + 1]) left++;\n                while (left < right && nums[right] === nums[right - 1]) right--;\n                left++;\n                right--;\n            }\n        }\n    }\n\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nFind all unique triplets in an array that sum to zero.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input array `nums` to facilitate the two-pointer technique.\n\n **Initialize Result Array:**\n   - Create an empty array `result` to store the triplets.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the third last element.\n   - Skip duplicates to avoid repeated triplets.\n\n **Two-Pointer Technique:**\n   - For each element, initialize two pointers: `left` at the next element and `right` at the last element.\n   - Calculate the sum of the current element and the elements at the `left` and `right` pointers.\n   - If the sum is less than zero, increment `left` to increase the sum.\n   - If the sum is greater than zero, decrement `right` to decrease the sum.\n   - If the sum is zero, push the triplet to the result and adjust both pointers."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            left, right = i + 1, len(nums) - 1\n\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if total < 0:\n                    left += 1\n                elif total > 0:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left + 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right - 1]:\n                        right -= 1\n                    left += 1\n                    right -= 1\n\n        return result",
      "explanation": "## 📝 Problem Recap\nFind all unique triplets in an array that sum to zero.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input list `nums` to facilitate the two-pointer technique.\n\n **Initialize Result List:**\n   - Create an empty list `result` to store the triplets.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the third last element.\n   - Skip duplicates to avoid repeated triplets.\n\n **Two-Pointer Technique:**\n   - For each element, initialize two pointers: `left` at the next element and `right` at the last element.\n   - Calculate the sum of the current element and the elements at the `left` and `right` pointers.\n   - If the sum is less than zero, increment `left` to increase the sum.\n   - If the sum is greater than zero, decrement `right` to decrease the sum.\n   - If the sum is zero, append the triplet to the result and adjust both pointers."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            int left = i + 1, right = nums.length - 1;\n\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                if (sum < 0) {\n                    left++;\n                } else if (sum > 0) {\n                    right--;\n                } else {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    left++;\n                    right--;\n                }\n            }\n        }\n\n        return result;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind all unique triplets in an array that sum to zero.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input array `nums` to facilitate the two-pointer technique.\n\n **Initialize Result List:**\n   - Create an empty list `result` to store the triplets.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the third last element.\n   - Skip duplicates to avoid repeated triplets.\n\n **Two-Pointer Technique:**\n   - For each element, initialize two pointers: `left` at the next element and `right` at the last element.\n   - Calculate the sum of the current element and the elements at the `left` and `right` pointers.\n   - If the sum is less than zero, increment `left` to increase the sum.\n   - If the sum is greater than zero, decrement `right` to decrease the sum.\n   - If the sum is zero, add the triplet to the result and adjust both pointers."
    }
  ]
  },
  {
  "slug": "16-3sum-closest",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function threeSumClosest(nums, target) {\n    nums.sort((a, b) => a - b);\n    let closest = Infinity;\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        let left = i + 1, right = nums.length - 1;\n\n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            if (Math.abs(sum - target) < Math.abs(closest - target)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else if (sum > target) {\n                right--;\n            } else {\n                return sum;\n            }\n        }\n    }\n\n    return closest;\n}",
      "explanation": "## 📝 Problem Recap\nFind the sum of three integers in an array that is closest to a given target.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input array `nums` to facilitate the two-pointer technique.\n\n **Initialize Closest Variable:**\n   - Set `closest` to `Infinity` to track the closest sum found.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the third last element.\n   - For each element, initialize two pointers: `left` at the next element and `right` at the last element.\n\n **Two-Pointer Technique:**\n   - Calculate the sum of the current element and the elements at the `left` and `right` pointers.\n   - If the absolute difference between this sum and the target is less than that of `closest`, update `closest`.\n   - If the sum is less than the target, increment `left` to increase the sum.\n   - If the sum is greater than the target, decrement `right` to decrease the sum.\n   - If the sum equals the target, return it immediately as it is the closest possible value.\n\n **Return Closest Sum:**\n   - After processing all elements, return `closest`."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        closest = float('inf')\n\n        for i in range(len(nums) - 2):\n            left, right = i + 1, len(nums) - 1\n\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if abs(total - target) < abs(closest - target):\n                    closest = total\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    return total\n\n        return closest",
      "explanation": "## 📝 Problem Recap\nFind the sum of three integers in an array that is closest to a given target.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input list `nums` to facilitate the two-pointer technique.\n\n **Initialize Closest Variable:**\n   - Set `closest` to `float('inf')` to track the closest sum found.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the third last element.\n   - For each element, initialize two pointers: `left` at the next element and `right` at the last element.\n\n **Two-Pointer Technique:**\n   - Calculate the sum of the current element and the elements at the `left` and `right` pointers.\n   - If the absolute difference between this sum and the target is less than that of `closest`, update `closest`.\n   - If the sum is less than the target, increment `left` to increase the sum.\n   - If the sum is greater than the target, decrement `right` to decrease the sum.\n   - If the sum equals the target, return it immediately as it is the closest possible value.\n\n **Return Closest Sum:**\n   - After processing all elements, return `closest`."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int closest = Integer.MAX_VALUE;\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1, right = nums.length - 1;\n\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                if (Math.abs(sum - target) < Math.abs(closest - target)) {\n                    closest = sum;\n                }\n                if (sum < target) {\n                    left++;\n                } else if (sum > target) {\n                    right--;\n                } else {\n                    return sum;\n                }\n            }\n        }\n\n        return closest;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind the sum of three integers in an array that is closest to a given target.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input array `nums` to facilitate the two-pointer technique.\n\n **Initialize Closest Variable:**\n   - Set `closest` to `Integer.MAX_VALUE` to track the closest sum found.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the third last element.\n   - For each element, initialize two pointers: `left` at the next element and `right` at the last element.\n\n **Two-Pointer Technique:**\n   - Calculate the sum of the current element and the elements at the `left` and `right` pointers.\n   - If the absolute difference between this sum and the target is less than that of `closest`, update `closest`.\n   - If the sum is less than the target, increment `left` to increase the sum.\n   - If the sum is greater than the target, decrement `right` to decrease the sum.\n   - If the sum equals the target, return it immediately as it is the closest possible value.\n\n **Return Closest Sum:**\n   - After processing all elements, return `closest`."
    }
  ]
  },
  {
  "slug": "17-letter-combinations-of-a-phone-number",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function letterCombinations(digits) {\n    if (!digits) return [];\n    const phoneMap = {\n        '2': 'abc',\n        '3': 'def',\n        '4': 'ghi',\n        '5': 'jkl',\n        '6': 'mno',\n        '7': 'pqrs',\n        '8': 'tuv',\n        '9': 'wxyz'\n    };\n    const result = [];\n\n    function backtrack(index, path) {\n        if (index === digits.length) {\n            result.push(path);\n            return;\n        }\n\n        const letters = phoneMap[digits[index]];\n        for (const letter of letters) {\n            backtrack(index + 1, path + letter);\n        }\n    }\n\n    backtrack(0, '');\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nGiven a string containing digits from 2-9, return all possible letter combinations that the number could represent.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Empty Input:**\n   - If the input `digits` is empty, return an empty array.\n\n **Define Phone Map:**\n   - Create a mapping of digits to their corresponding letters.\n\n **Initialize Result Array:**\n   - Create an empty array `result` to store the combinations.\n\n **Backtracking Function:**\n   - Define a recursive function `backtrack` that takes the current index and the current path as arguments.\n   - If the index equals the length of `digits`, push the current path to `result`.\n   - Otherwise, get the letters corresponding to the current digit and iterate through them, calling `backtrack` recursively with the next index and updated path.\n\n **Start Backtracking:**\n   - Call `backtrack` starting from index 0 with an empty path.\n\n **Return Result:**\n   - After all combinations are generated, return the `result` array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        phoneMap = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        result = []\n\n        def backtrack(index, path):\n            if index == len(digits):\n                result.append(path)\n                return\n            letters = phoneMap[digits[index]]\n            for letter in letters:\n                backtrack(index + 1, path + letter)\n\n        backtrack(0, '')\n        return result\n",
      "explanation": "## 📝 Problem Recap\nGiven a string containing digits from 2-9, return all possible letter combinations that the number could represent.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Empty Input:**\n   - If the input `digits` is empty, return an empty array.\n\n **Define Phone Map:**\n   - Create a mapping of digits to their corresponding letters.\n\n **Initialize Result Array:**\n   - Create an empty array `result` to store the combinations.\n\n **Backtracking Function:**\n   - Define a recursive function `backtrack` that takes the current index and the current path as arguments.\n   - If the index equals the length of `digits`, push the current path to `result`.\n   - Otherwise, get the letters corresponding to the current digit and iterate through them, calling `backtrack` recursively with the next index and updated path.\n\n **Start Backtracking:**\n   - Call `backtrack` starting from index 0 with an empty path.\n\n **Return Result:**\n   - After all combinations are generated, return the `result` array."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public List<String> letterCombinations(String digits) {\n        if (digits.isEmpty()) return new ArrayList<>();\n        String[] phoneMap = {\n            \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\n        };\n        List<String> result = new ArrayList<>();\n\n        backtrack(digits, 0, new StringBuilder(), result, phoneMap);\n        return result;\n    }\n\n    private void backtrack(String digits, int index, StringBuilder path, List<String> result, String[] phoneMap) {\n        if (index == digits.length()) {\n            result.add(path.toString());\n            return;\n        }\n        String letters = phoneMap[digits.charAt(index) - '0'];\n        for (char letter : letters.toCharArray()) {\n            path.append(letter);\n            backtrack(digits, index + 1, path, result, phoneMap);\n            path.deleteCharAt(path.length() - 1);\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGiven a string containing digits from 2-9, return all possible letter combinations that the number could represent.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Empty Input:**\n   - If the input `digits` is empty, return an empty list.\n\n **Define Phone Map:**\n   - Create an array `phoneMap` that maps each digit to its corresponding letters.\n\n **Initialize Result List:**\n   - Create an empty list `result` to store the combinations.\n\n **Backtracking Function:**\n   - Define a recursive function `backtrack` that takes the current index, current path, and the result list as arguments.\n   - If the index equals the length of `digits`, add the current path to `result`.\n   - Otherwise, get the letters corresponding to the current digit and iterate through them, appending each letter to the path and calling `backtrack` recursively with the next index.\n   - After returning from recursion, remove the last character from the path to backtrack.\n\n **Start Backtracking:**\n   - Call `backtrack` starting from index 0 with an empty path.\n\n **Return Result:**\n   - After all combinations are generated, return the `result` list."
    }
  ]
  },
  {
  "slug": "18-4sum",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function fourSum(nums, target) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 3; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        for (let j = i + 1; j < nums.length - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n            let left = j + 1, right = nums.length - 1;\n\n            while (left < right) {\n                const sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if (sum < target) {\n                    left++;\n                } else if (sum > target) {\n                    right--;\n                } else {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                    while (left < right && nums[left] === nums[left + 1]) left++;\n                    while (left < right && nums[right] === nums[right - 1]) right--;\n                    left++;\n                    right--;\n                }\n            }\n        }\n    }\n\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nFind all unique quadruplets in an array that sum to a given target.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input array `nums` to facilitate the two-pointer technique.\n\n **Initialize Result Array:**\n   - Create an empty array `result` to store the quadruplets.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the fourth last element.\n   - Skip duplicates to avoid repeated quadruplets.\n   - For each element, loop through the next elements up to the third last element, again skipping duplicates.\n\n **Two-Pointer Technique:**\n   - For each pair of elements, initialize two pointers: `left` at the next element and `right` at the last element.\n   - While `left` is less than `right`, calculate the sum of the four elements.\n   - If the sum is equal to the target, add the quadruplet to the result and move both pointers.\n   - If the sum is less than the target, move the left pointer to the right.\n   - If the sum is greater than the target, move the right pointer to the left.\n\n **Return Result:**\n   - After all iterations, return the `result` array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]:\n                    continue\n                left, right = j + 1, len(nums) - 1\n\n                while left < right:\n                    total = nums[i] + nums[j] + nums[left] + nums[right]\n                    if total < target:\n                        left += 1\n                    elif total > target:\n                        right -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[left], nums[right]])\n                        while left < right and nums[left] == nums[left + 1]:\n                            left += 1\n                        while left < right and nums[right] == nums[right - 1]:\n                            right -= 1\n                        left += 1\n                        right -= 1\n\n        return result",
      "explanation": "## 📝 Problem Recap\nFind all unique quadruplets in an array that sum to a given target.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input list `nums` to facilitate the two-pointer technique.\n\n **Initialize Result List:**\n   - Create an empty list `result` to store the quadruplets.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the fourth last element.\n   - Skip duplicates to avoid repeated quadruplets.\n   - For each element, loop through the next elements up to the third last element, again skipping duplicates.\n\n **Two-Pointer Technique:**\n   - For each pair of elements, initialize two pointers: `left` at the next element and `right` at the last element.\n   - While `left` is less than `right`, calculate the sum of the four elements.\n   - If the sum is equal to the target, add the quadruplet to the result and move both pointers.\n   - If the sum is less than the target, move the left pointer to the right.\n   - If the sum is greater than the target, move the right pointer to the left.\n\n **Return Result:**\n   - After all iterations, return the `result` array."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 3; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            for (int j = i + 1; j < nums.length - 2; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n                int left = j + 1, right = nums.length - 1;\n\n                while (left < right) {\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                    if (sum < target) {\n                        left++;\n                    } else if (sum > target) {\n                        right--;\n                    } else {\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n                        left++;\n                        right--;\n                    }\n                }\n            }\n        }\n\n        return result;\n }\n}",
      "explanation": "## 📝 Problem Recap\nFind all unique quadruplets in an array that sum to a given target.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort the Array:**\n   - Sort the input array `nums` to facilitate the two-pointer technique.\n\n **Initialize Result List:**\n   - Create an empty list `result` to store the quadruplets.\n\n **Iterate Through the Array:**\n   - Loop through each element in `nums` up to the fourth last element.\n   - Skip duplicates to avoid repeated quadruplets.\n   - For each element, loop through the next elements up to the third last element, again skipping duplicates.\n\n **Two-Pointer Technique:**\n   - For each pair of elements, initialize two pointers: `left` at the next element and `right` at the last element.\n   - While `left` is less than `right`, calculate the sum of the four elements.\n   - If the sum is equal to the target, add the quadruplet to the result and move both pointers.\n   - If the sum is less than the target, move the left pointer to the right.\n   - If the sum is greater than the target, move the right pointer to the left.\n\n **Return Result:**\n   - After all iterations, return the `result` list."
    }
  ]
    },
{
  "slug": "19-remove-nth-node-from-end-of-list",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function removeNthFromEnd(head, n) {\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let first = dummy;\n    let second = dummy;\n\n    for (let i = 0; i <= n; i++) {\n        first = first.next;\n    }\n\n    while (first) {\n        first = first.next;\n        second = second.next;\n    }\n\n    second.next = second.next.next;\n    return dummy.next;\n}",
      "explanation": "## 📝 Problem Recap\nRemove the nth node from the end of a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Create a Dummy Node:**\n   - Initialize a dummy node that points to the head of the list to handle edge cases.\n\n **Initialize Two Pointers:**\n   - Set both `first` and `second` pointers to the dummy node.\n\n **Advance First Pointer:**\n   - Move the `first` pointer `n + 1` steps ahead to maintain a gap of `n` nodes between `first` and `second`.\n\n **Move Both Pointers:**\n   - Move both pointers until `first` reaches the end of the list.\n   - At this point, `second` will be pointing to the node just before the one we want to remove.\n\n **Remove the Node:**\n   - Adjust the `next` pointer of `second` to skip the nth node from the end.\n\n **Return New Head:**\n   - Return the next node of the dummy node as the new head of the modified list."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = ListNode(0)\n        dummy.next = head\n        first = dummy\n        second = dummy\n\n        for _ in range(n + 1):\n            first = first.next\n\n        while first:\n            first = first.next\n            second = second.next\n\n        second.next = second.next.next\n        return dummy.next",
      "explanation":
"## 📝 Problem Recap\nRemove the nth node from the end of a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Create a Dummy Node:**\n   - Initialize a dummy node that points to the head of the list to handle edge cases.\n\n **Initialize Two Pointers:**\n   - Set both `first` and `second` pointers to the dummy node.\n\n **Advance First Pointer:**\n   - Move the `first` pointer `n + 1` steps ahead to maintain a gap of `n` nodes between `first` and `second`.\n\n **Move Both Pointers:**\n   - Move both pointers until `first` reaches the end of the list.\n   - At this point, `second` will be pointing to the node just before the one we want to remove.\n\n **Remove the Node:**\n   - Adjust the `next` pointer of `second` to skip the nth node from the end.\n\n **Return New Head:**\n   - Return the next node of the dummy node as the new head of the modified list."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode first = dummy;\n        ListNode second = dummy;\n\n        for (int i = 0; i <= n; i++) {\n            first = first.next;\n        }\n\n        while (first != null) {\n            first = first.next;\n            second = second.next;\n        }\n\n        second.next = second.next.next;\n        return dummy.next;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nRemove the nth node from the end of a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Create a Dummy Node:**\n   - Initialize a dummy node that points to the head of the list to handle edge cases.\n\n **Initialize Two Pointers:**\n   - Set both `first` and `second` pointers to the dummy node.\n\n **Advance First Pointer:**\n   - Move the `first` pointer `n + 1` steps ahead to maintain a gap of `n` nodes between `first` and `second`.\n\n **Move Both Pointers:**\n   - Move both pointers until `first` reaches the end of the list.\n   - At this point, `second` will be pointing to the node just before the one we want to remove.\n\n **Remove the Node:**\n   - Adjust the `next` pointer of `second` to skip the nth node from the end.\n\n **Return New Head:**\n   - Return the next node of the dummy node as the new head of the modified list."
    }
  ]
  },
{
  "slug": "20-valid-parentheses",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function isValid(s) {\n    const stack = [];\n    const map = { '(': ')', '{': '}', '[': ']' };\n\n    for (const char of s) {\n        if (map[char]) {\n            stack.push(map[char]);\n        } else if (stack.pop() !== char) {\n            return false;\n        }\n    }\n\n    return stack.length === 0;\n}",
      "explanation": "## 📝 Problem Recap\nCheck if a string containing parentheses is valid.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Stack:**\n   - Create an empty stack to keep track of opening parentheses.\n\n **Define Parentheses Map:**\n   - Create a mapping of opening parentheses to their corresponding closing parentheses.\n\n **Iterate Through Characters:**\n   - For each character in the string:\n     - If it is an opening parenthesis, push its corresponding closing parenthesis onto the stack.\n     - If it is a closing parenthesis, check if it matches the top of the stack. If not, return false.\n\n **Check Stack Length:**\n   - After processing all characters, return true if the stack is empty (all parentheses matched), otherwise return false."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        map = { '(': ')', '{': '}', '[': ']' }\n\n        for char in s:\n            if char in map:\n                stack.append(map[char])\n            elif not stack or stack.pop() != char:\n                return False\n\n        return not stack",
      "explanation": "## 📝 Problem Recap\nCheck if a string containing parentheses is valid.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Stack:**\n   - Create an empty list `stack` to keep track of opening parentheses.\n\n **Define Parentheses Map:**\n   - Create a mapping of opening parentheses to their corresponding closing parentheses.\n\n **Iterate Through Characters:**\n   - For each character in the string:\n     - If it is an opening parenthesis, push its corresponding closing parenthesis onto the stack.\n     - If it is a closing parenthesis, check if it matches the top of the stack. If not, return false.\n\n **Check Stack Length:**\n   - After processing all characters, return true if the stack is empty (all parentheses matched), otherwise return false."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        Map<Character, Character> map = new HashMap<>();\n        map.put('(', ')');\n        map.put('{', '}');\n        map.put('[', ']');\n\n        for (char c : s.toCharArray()) {\n            if (map.containsKey(c)) {\n                stack.push(map.get(c));\n            } else if (stack.isEmpty() || stack.pop() != c) {\n                return false;\n            }\n        }\n\n        return stack.isEmpty();\n    }\n}",
      "explanation": "## 📝 Problem Recap\nCheck if a string containing parentheses is valid.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Stack:**\n   - Create a stack to keep track of opening parentheses.\n\n **Define Parentheses Map:**\n   - Create a mapping of opening parentheses to their corresponding closing parentheses.\n\n **Iterate Through Characters:**\n   - For each character in the string:\n     - If it is an opening parenthesis, push its corresponding closing parenthesis onto the stack.\n     - If it is a closing parenthesis, check if it matches the top of the stack. If not, return false.\n\n **Check Stack Length:**\n   - After processing all characters, return true if the stack is empty (all parentheses matched), otherwise return false."
    }
  ]
},
{
  "slug": "21-merge-two-sorted-lists",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function mergeTwoLists(l1, l2) {\n    if (!l1) return l2;\n    if (!l2) return l1;\n\n    if (l1.val < l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2);\n        return l1;\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next);\n        return l2;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nMerge two sorted linked lists into one sorted linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Cases:**\n   - If one of the lists is empty, return the other list.\n\n **Compare Values:**\n   - Compare the values of the heads of both lists.\n   - Recursively merge the next node of the list with the smaller head value with the other list.\n   - Return the node with the smaller value as the new head."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n\n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2",
      "explanation": "## 📝 Problem Recap\nMerge two sorted linked lists into one sorted linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Cases:**\n   - If one of the lists is empty, return the other list.\n\n **Compare Values:**\n   - Compare the values of the heads of both lists.\n   - Recursively merge the next node of the list with the smaller head value with the other list.\n   - Return the node with the smaller value as the new head."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n\n        if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nMerge two sorted linked lists into one sorted linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Cases:**\n   - If one of the lists is empty, return the other list.\n\n **Compare Values:**\n   - Compare the values of the heads of both lists.\n   - Recursively merge the next node of the list with the smaller head value with the other list.\n   - Return the node with the smaller value as the new head."
    }
  ]
  },
{
  "slug": "22-generate-parentheses",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function generateParenthesis(n) {\n    const result = [];\n\n    function backtrack(current, open, close) {\n        if (current.length === n * 2) {\n            result.push(current);\n            return;\n        }\n\n        if (open < n) {\n            backtrack(current + '(', open + 1, close);\n        }\n        if (close < open) {\n            backtrack(current + ')', open, close + 1);\n        }\n    }\n\n    backtrack('', 0, 0);\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nGenerate all combinations of well-formed parentheses for a given number of pairs.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result Array:**\n   - Create an empty array `result` to store the valid combinations.\n\n **Backtracking Function:**\n   - Define a recursive function `backtrack` that takes the current string, count of open parentheses, and count of close parentheses as arguments.\n   - If the length of the current string equals `2 * n`, add it to the result.\n   - If the count of open parentheses is less than `n`, add an open parenthesis and call `backtrack` recursively.\n   - If the count of close parentheses is less than the count of open parentheses, add a close parenthesis and call `backtrack` recursively.\n\n **Start Backtracking:**\n   - Call `backtrack` with an empty string and both counts set to zero.\n\n **Return Result:**\n   - After generating all combinations, return the `result` array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        result = []\n\n        def backtrack(current, open_count, close_count):\n            if len(current) == n * 2:\n                result.append(current)\n                return\n            if open_count < n:\n                backtrack(current + '(', open_count + 1, close_count)\n            if close_count < open_count:\n                backtrack(current + ')', open_count, close_count + 1)\n\n        backtrack('', 0, 0)\n        return result",
      "explanation": "## 📝 Problem Recap\nGenerate all combinations of well-formed parentheses for a given number of pairs.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result List:**\n   - Create an empty list `result` to store the valid combinations.\n\n **Backtracking Function:**\n   - Define a recursive function `backtrack` that takes the current string, count of open parentheses, and count of close parentheses as arguments.\n   - If the length of the current string equals `2 * n`, add it to the result.\n   - If the count of open parentheses is less than `n`, add an open parenthesis and call `backtrack` recursively.\n   - If the count of close parentheses is less than the count of open parentheses, add a close parenthesis and call `backtrack` recursively.\n\n **Start Backtracking:**\n   - Call `backtrack` with an empty string and both counts set to zero.\n\n **Return Result:**\n   - After generating all combinations, return the `result` list."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> result = new ArrayList<>();\n\n        backtrack(result, \"\", 0, 0, n);\n        return result;\n    }\n\n    private void backtrack(List<String> result, String current, int openCount, int closeCount, int n) {\n        if (current.length() == n * 2) {\n            result.add(current);\n            return;\n        }\n        if (openCount < n) {\n            backtrack(result, current + '(', openCount + 1, closeCount, n);\n        }\n        if (closeCount < openCount) {\n            backtrack(result, current + ')', openCount, closeCount + 1, n);\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGenerate all combinations of well-formed parentheses for a given number of pairs.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result List:**\n   - Create an empty list `result` to store the valid combinations.\n\n **Backtracking Function:**\n   - Define a recursive function `backtrack` that takes the result list, current string, count of open parentheses, count of close parentheses, and total pairs as arguments.\n   - If the length of the current string equals `2 * n`, add it to the result.\n   - If the count of open parentheses is less than `n`, add an open parenthesis and call `backtrack` recursively.\n   - If the count of close parentheses is less than the count of open parentheses, add a close parenthesis and call `backtrack` recursively.\n\n **Start Backtracking:**\n   - Call `backtrack` with an empty string and both counts set to zero.\n\n **Return Result:**\n   - After generating all combinations, return the `result` list."
    }
  ]
  },
{
  "slug": "23-merge-k-sorted-lists",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function mergeKLists(lists) {\n    if (lists.length === 0) return null;\n\n    while (lists.length > 1) {\n        const mergedLists = [];\n        for (let i = 0; i < lists.length; i += 2) {\n            if (i + 1 < lists.length) {\n                mergedLists.push(mergeTwoLists(lists[i], lists[i + 1]));\n            } else {\n                mergedLists.push(lists[i]);\n            }\n        }\n        lists = mergedLists;\n    }\n\n    return lists[0];\n}\n\nfunction mergeTwoLists(l1, l2) {\n    if (!l1) return l2;\n    if (!l2) return l1;\n\n    if (l1.val < l2.val) {\n        l1.next = mergeTwoLists(l1.next, l2);\n        return l1;\n    } else {\n        l2.next = mergeTwoLists(l1, l2.next);\n        return l2;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nMerge k sorted linked lists into one sorted linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the input list is empty, return null.\n\n **Iterative Merging:**\n   - While there are more than one list in `lists`, merge pairs of lists:\n     - Create an empty array `mergedLists` to store the merged results.\n     - Iterate through the `lists` array in pairs, merging each pair using the `mergeTwoLists` function.\n     - If there is an odd number of lists, add the last list as it is.\n     - Update `lists` to be `mergedLists`.\n\n **Return Result:**\n   - After all merges are done, return the first list in `lists` as the final merged result."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        if not lists:\n            return None\n\n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                if i + 1 < len(lists):\n                    mergedLists.append(self.mergeTwoLists(lists[i], lists[i + 1]))\n                else:\n                    mergedLists.append(lists[i])\n            lists = mergedLists\n\n        return lists[0]\n\n    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:\n        if not l1:\n            return l2\n        if not l2:\n            return l1\n\n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2",
      "explanation": "## 📝 Problem Recap\nMerge k sorted linked lists into one sorted linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the input list is empty, return None.\n\n **Iterative Merging:**\n   - While there are more than one list in `lists`, merge pairs of lists:\n     - Create an empty list `mergedLists` to store the merged results.\n     - Iterate through the `lists` array in pairs, merging each pair using the `mergeTwoLists` function.\n     - If there is an odd number of lists, add the last list as it is.\n     - Update `lists` to be `mergedLists`.\n\n **Return Result:**\n   - After all merges are done, return the first list in `lists` as the final merged result."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists.length == 0) return null;\n\n        while (lists.length > 1) {\n            List<ListNode> mergedLists = new ArrayList<>();\n            for (int i = 0; i < lists.length; i += 2) {\n                if (i + 1 < lists.length) {\n                    mergedLists.add(mergeTwoLists(lists[i], lists[i + 1]));\n                } else {\n                    mergedLists.add(lists[i]);\n                }\n            }\n            lists = mergedLists.toArray(new ListNode[0]);\n        }\n\n        return lists[0];\n    }\n\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n\n        if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n }",
      "explanation": "## 📝 Problem Recap\nMerge k sorted linked lists into one sorted linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the input array is empty, return null.\n\n **Iterative Merging:**\n   - While there are more than one list in `lists`, merge pairs of lists:\n     - Create an empty list `mergedLists` to store the merged results.\n     - Iterate through the `lists` array in pairs, merging each pair using the `mergeTwoLists` function.\n     - If there is an odd number of lists, add the last list as it is.\n     - Update `lists` to be `mergedLists` converted back to an array.\n\n **Return Result:**\n   - After all merges are done, return the first list in `lists` as the final merged result."
    }
  ]
  },
{
  "slug": "24-swap-nodes-in-pairs",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function swapPairs(head) {\n    if (!head || !head.next) return head;\n\n    let dummy = new ListNode(0);\n    dummy.next = head;\n    let current = dummy;\n\n    while (current.next && current.next.next) {\n        let first = current.next;\n        let second = first.next;\n\n        first.next = second.next;\n        second.next = first;\n        current.next = second;\n\n        current = first;\n    }\n\n    return dummy.next;\n}",
      "explanation": "## 📝 Problem Recap\nSwap every two adjacent nodes in a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the list is empty or has only one node, return the head as is.\n\n **Initialize Dummy Node:**\n   - Create a dummy node that points to the head of the list to handle edge cases.\n\n **Iterate Through the List:**\n   - Use a pointer `current` to traverse the list.\n   - While there are at least two nodes to swap:\n     - Identify the first and second nodes to swap.\n     - Adjust pointers to swap the nodes.\n     - Move `current` to the next pair of nodes.\n\n **Return New Head:**\n   - After all swaps, return the next node of the dummy node as the new head."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        current = dummy\n\n        while current.next and current.next.next:\n            first = current.next\n            second = first.next\n\n            first.next = second.next\n            second.next = first\n            current.next = second\n\n            current = first\n\n        return dummy.next",
      "explanation": "## 📝 Problem Recap\nSwap every two adjacent nodes in a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the list is empty or has only one node, return the head as is.\n\n **Initialize Dummy Node:**\n   - Create a dummy node that points to the head of the list to handle edge cases.\n\n **Iterate Through the List:**\n   - Use a pointer `current` to traverse the list.\n   - While there are at least two nodes to swap:\n     - Identify the first and second nodes to swap.\n     - Adjust pointers to swap the nodes.\n     - Move `current` to the next pair of nodes.\n\n **Return New Head:**\n   - After all swaps, return the next node of the dummy node as the new head."
    
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode current = dummy;\n\n        while (current.next != null && current.next.next != null) {\n            ListNode first = current.next;\n            ListNode second = first.next;\n\n            first.next = second.next;\n            second.next = first;\n            current.next = second;\n\n            current = first;\n        }\n\n        return dummy.next;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nSwap every two adjacent nodes in a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the list is empty or has only one node, return the head as is.\n\n **Initialize Dummy Node:**\n   - Create a dummy node that points to the head of the list to handle edge cases.\n\n **Iterate Through the List:**\n   - Use a pointer `current` to traverse the list.\n   - While there are at least two nodes to swap:\n     - Identify the first and second nodes to swap.\n     - Adjust pointers to swap the nodes.\n     - Move `current` to the next pair of nodes.\n\n **Return New Head:**\n   - After all swaps, return the next node of the dummy node as the new head."
    }
  ]
  },
{
  "slug": "25-reverse-nodes-in-k-group",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function reverseKGroup(head, k) {\n    let count = 0;\n    let current = head;\n\n    while (current && count < k) {\n        current = current.next;\n        count++;\n    }\n\n    if (count < k) return head;\n\n    let prev = null;\n    current = head;\n\n    for (let i = 0; i < k; i++) {\n        const next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n    }\n\n    head.next = reverseKGroup(current, k);\n    return prev;\n}",
      "explanation": "## 📝 Problem Recap\nReverse nodes in k-group in a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Count Nodes:**\n   - Traverse the list to count the number of nodes up to `k`. If there are fewer than `k` nodes, return the head as is.\n\n **Reverse k Nodes:**\n   - Reverse the first `k` nodes by adjusting pointers.\n   - Keep track of the previous node to link the reversed part with the rest of the list.\n\n **Recursive Call:**\n   - Call the function recursively for the remaining nodes and link them to the end of the reversed part.\n\n **Return New Head:**\n   - Return the new head of the reversed segment."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        count = 0\n        current = head\n\n        while current and count < k:\n            current = current.next\n            count += 1\n\n        if count < k:\n            return head\n\n        prev = None\n        current = head\n\n        for _ in range(k):\n            next_node = current.next\n            current.next = prev\n            prev = current\n            current = next_node\n\n        head.next = self.reverseKGroup(current, k)\n        return prev",
      "explanation": "## 📝 Problem Recap\nReverse nodes in k-group in a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Count Nodes:**\n   - Traverse the list to count the number of nodes up to `k`. If there are fewer than `k` nodes, return the head as is.\n\n **Reverse k Nodes:**\n   - Reverse the first `k` nodes by adjusting pointers.\n   - Keep track of the previous node to link the reversed part with the rest of the list.\n\n **Recursive Call:**\n   - Call the function recursively for the remaining nodes and link them to the end of the reversed part.\n\n **Return New Head:**\n   - Return the new head of the reversed segment."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        int count = 0;\n        ListNode current = head;\n\n        while (current != null && count < k) {\n            current = current.next;\n            count++;\n        }\n\n        if (count < k) return head;\n\n        ListNode prev = null;\n        current = head;\n\n        for (int i = 0; i < k; i++) {\n            ListNode next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n\n        head.next = reverseKGroup(current, k);\n        return prev;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nReverse nodes in k-group in a linked list.\n\n---\n\n## Step-by-Step Explanation\n\n **Count Nodes:**\n   - Traverse the list to count the number of nodes up to `k`. If there are fewer than `k` nodes, return the head as is.\n\n **Reverse k Nodes:**\n   - Reverse the first `k` nodes by adjusting pointers.\n   - Keep track of the previous node to link the reversed part with the rest of the list.\n\n **Recursive Call:**\n   - Call the function recursively for the remaining nodes and link them to the end of the reversed part.\n\n **Return New Head:**\n   - Return the new head of the reversed segment."
    }
  ]
  },
{
  "slug": "26-remove-duplicates-from-sorted-array",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n\n    let uniqueIndex = 0;\n\n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] !== nums[uniqueIndex]) {\n            uniqueIndex++;\n            nums[uniqueIndex] = nums[i];\n        }\n    }\n\n    return uniqueIndex + 1;\n}",
      "explanation": "## 📝 Problem Recap\nRemove duplicates from a sorted array in-place and return the new length.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the array is empty, return 0.\n\n **Initialize Unique Index:**\n   - Start with `uniqueIndex` at 0, which will track the position of the last unique element.\n\n **Iterate Through Array:**\n   - Loop through the array starting from the second element.\n   - If the current element is different from the last unique element, increment `uniqueIndex` and update the next position with the current element.\n\n **Return Length:**\n   - Return `uniqueIndex + 1` as the new length of the array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        unique_index = 0\n\n        for i in range(1, len(nums)):\n            if nums[i] != nums[unique_index]:\n                unique_index += 1\n                nums[unique_index] = nums[i]\n\n        return unique_index + 1",
      "explanation": "## 📝 Problem Recap\nRemove duplicates from a sorted array in-place and return the new length.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the array is empty, return 0.\n\n **Initialize Unique Index:**\n   - Start with `unique_index` at 0, which will track the position of the last unique element.\n\n **Iterate Through Array:**\n   - Loop through the array starting from the second element.\n   - If the current element is different from the last unique element, increment `unique_index` and update the next position with the current element.\n\n **Return Length:**\n   - Return `unique_index + 1` as the new length of the array."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n\n        int uniqueIndex = 0;\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] != nums[uniqueIndex]) {\n                uniqueIndex++;\n                nums[uniqueIndex] = nums[i];\n            }\n        }\n\n        return uniqueIndex + 1;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nRemove duplicates from a sorted array in-place and return the new length.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If the array is empty, return 0.\n\n **Initialize Unique Index:**\n   - Start with `uniqueIndex` at 0, which will track the position of the last unique element.\n\n **Iterate Through Array:**\n   - Loop through the array starting from the second element.\n   - If the current element is different from the last unique element, increment `uniqueIndex` and update the next position with the current element.\n\n **Return Length:**\n   - Return `uniqueIndex + 1` as the new length of the array."
    }
  ]
  },
{
  "slug": "27-remove-element",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function removeElement(nums, val) {\n    let k = 0;\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n\n    return k;\n}",
      "explanation": "## 📝 Problem Recap\nRemove all instances of a specific value from an array in-place and return the new length.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Counter:**\n   - Start with a counter `k` at 0 to track the position of the next unique element.\n\n **Iterate Through Array:**\n   - Loop through the array and check each element.\n   - If the current element is not equal to the value to be removed, assign it to the position `k` and increment `k`.\n\n **Return Length:**\n   - After processing all elements, return `k` as the new length of the array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        k = 0\n\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[k] = nums[i]\n                k += 1\n\n        return k",
      "explanation": "## 📝 Problem Recap\nRemove all instances of a specific value from an array in-place and return the new length.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Counter:**\n   - Start with a counter `k` at 0 to track the position of the next unique element.\n\n **Iterate Through Array:**\n   - Loop through the array and check each element.\n   - If the current element is not equal to the value to be removed, assign it to the position `k` and increment `k`.\n\n **Return Length:**\n   - After processing all elements, return `k` as the new length of the array."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int removeElement(int[] nums, int val) {\n        int k = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != val) {\n                nums[k] = nums[i];\n                k++;\n            }\n        }\n\n        return k;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nRemove all instances of a specific value from an array in-place and return the new length.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Counter:**\n   - Start with a counter `k` at 0 to track the position of the next unique element.\n\n **Iterate Through Array:**\n   - Loop through the array and check each element.\n   - If the current element is not equal to the value to be removed, assign it to the position `k` and increment `k`.\n\n **Return Length:**\n   - After processing all elements, return `k` as the new length of the array."
    }
  ]
  },
{
  "slug": "28-implement-strstr",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function strStr(haystack, needle) {\n    if (needle === '') return 0;\n\n    for (let i = 0; i <= haystack.length - needle.length; i++) {\n        if (haystack.substring(i, i + needle.length) === needle) {\n            return i;\n        }\n    }\n\n    return -1;\n}",
      "explanation": "## 📝 Problem Recap\nImplement the strStr() function to find the first occurrence of a substring in a string.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Empty Needle:**\n   - If the needle is an empty string, return 0.\n\n **Iterate Through Haystack:**\n   - Loop through the haystack up to the point where the remaining characters are enough to match the needle.\n   - Use `substring` to check if the current segment matches the needle.\n\n **Return Index:**\n   - If a match is found, return the starting index. If no match is found, return -1."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if not needle:\n            return 0\n\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i + len(needle)] == needle:\n                return i\n\n        return -1",
      "explanation": "## 📝 Problem Recap\nImplement the strStr() function to find the first occurrence of a substring in a string.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Empty Needle:**\n   - If the needle is an empty string, return 0.\n\n **Iterate Through Haystack:**\n   - Loop through the haystack up to the point where the remaining characters are enough to match the needle.\n   - Use slicing to check if the current segment matches the needle.\n\n **Return Index:**\n   - If a match is found, return the starting index. If no match is found, return -1."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.isEmpty()) return 0;\n\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\n            if (haystack.substring(i, i + needle.length()).equals(needle)) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nImplement the strStr() function to find the first occurrence of a substring in a string.\n\n---\n\n## Step-by-Step Explanation\n\n **Check Empty Needle:**\n   - If the needle is an empty string, return 0.\n\n **Iterate Through Haystack:**\n   - Loop through the haystack up to the point where the remaining characters are enough to match the needle.\n   - Use `substring` to check if the current segment matches the needle.\n\n **Return Index:**\n   - If a match is found, return the starting index. If no match is found, return -1."
    }
  ]
  },
{
  "slug": "29-divide-two-integers",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function divide(dividend, divisor) {\n    if (dividend === 0) return 0;\n    if (divisor === 0) throw new Error('Division by zero');\n\n    const isNegative = (dividend < 0) !== (divisor < 0);\n    dividend = Math.abs(dividend);\n    divisor = Math.abs(divisor);\n\n    let quotient = 0;\n\n    while (dividend >= divisor) {\n        dividend -= divisor;\n        quotient++;\n    }\n\n    return isNegative ? -quotient : quotient;\n}",
      "explanation": "## 📝 Problem Recap\nDivide two integers without using multiplication, division, or mod operator.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Zero:**\n   - If the dividend is zero, return 0.\n   - If the divisor is zero, throw an error for division by zero.\n\n **Determine Sign:**\n   - Check if the result should be negative based on the signs of dividend and divisor.\n   - Convert both numbers to their absolute values.\n\n **Perform Division:**\n   - Use a loop to subtract the divisor from the dividend until the dividend is less than the divisor.\n   - Count how many times this subtraction occurs to get the quotient.\n\n **Return Result:**\n   - Return the quotient with the correct sign."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        if dividend == 0:\n            return 0\n        if divisor == 0:\n            raise ValueError('Division by zero')\n\n        is_negative = (dividend < 0) != (divisor < 0)\n        dividend, divisor = abs(dividend), abs(divisor)\n\n        quotient = 0\n\n        while dividend >= divisor:\n            dividend -= divisor\n            quotient += 1\n\n        return -quotient if is_negative else quotient",
      "explanation": "## 📝 Problem Recap\nDivide two integers without using multiplication, division, or mod operator.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Zero:**\n   - If the dividend is zero, return 0.\n   - If the divisor is zero, throw an error for division by zero.\n\n **Determine Sign:**\n   - Check if the result should be negative based on the signs of dividend and divisor.\n   - Convert both numbers to their absolute values.\n\n **Perform Division:**\n   - Use a loop to subtract the divisor from the dividend until the dividend is less than the divisor.\n   - Count how many times this subtraction occurs to get the quotient.\n\n **Return Result:**\n   - Return the quotient with the correct sign."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int divide(int dividend, int divisor) {\n        if (dividend == 0) return 0;\n        if (divisor == 0) throw new ArithmeticException(\"Division by zero\");\n\n        boolean isNegative = (dividend < 0) != (divisor < 0);\n        dividend = Math.abs(dividend);\n        divisor = Math.abs(divisor);\n\n        int quotient = 0;\n\n        while (dividend >= divisor) {\n            dividend -= divisor;\n            quotient++;\n        }\n\n        return isNegative ? -quotient : quotient;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nDivide two integers without using multiplication, division, or mod operator.\n\n---\n\n## Step-by-Step Explanation\n\n **Check for Zero:**\n   - If the dividend is zero, return 0.\n   - If the divisor is zero, throw an error for division by zero.\n\n **Determine Sign:**\n   - Check if the result should be negative based on the signs of dividend and divisor.\n   - Convert both numbers to their absolute values.\n\n **Perform Division:**\n   - Use a loop to subtract the divisor from the dividend until the dividend is less than the divisor.\n   - Count how many times this subtraction occurs to get the quotient.\n\n **Return Result:**\n   - Return the quotient with the correct sign."
    }
  ]
},
{
  "slug": "30-substring-with-concatenation-of-all-words",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function findSubstring(s, words) {\n    if (s.length === 0 || words.length === 0) return [];\n\n    const wordLength = words[0].length;\n    const totalWordsLength = wordLength * words.length;\n    const wordCount = {};\n\n    for (const word of words) {\n        wordCount[word] = (wordCount[word] || 0) + 1;\n    }\n\n    const result = [];\n\n    for (let i = 0; i <= s.length - totalWordsLength; i++) {\n        const seenWords = {};\n        let j = 0;\n\n        while (j < words.length) {\n            const wordIndex = i + j * wordLength;\n            const word = s.substring(wordIndex, wordIndex + wordLength);\n\n            if (!wordCount[word]) break;\n            seenWords[word] = (seenWords[word] || 0) + 1;\n\n            if (seenWords[word] > wordCount[word]) break;\n            j++;\n        }\n\n        if (j === words.length) result.push(i);\n    }\n\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nFind all starting indices of substring(s) in a string that is a concatenation of each word in a list exactly once.\n\n---\n\n## Step-by-Step Explanation\n\n **Edge Cases:**\n   - If the string or the list of words is empty, return an empty array.\n\n **Initialize Variables:**\n   - Calculate the length of each word and the total length of all words combined.\n   - Create a frequency map to count occurrences of each word in the list.\n\n **Iterate Through String:**\n   - Loop through the string up to the point where a full concatenation could fit.\n   - For each starting index, check if the substring matches the words in the list.\n   - Use a nested loop to check each segment of the substring against the frequency map.\n   - If all words are found with correct counts, add the starting index to the result.\n\n **Return Result:**\n   - Return an array of starting indices where the concatenation occurs."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n\n        word_length = len(words[0])\n        total_words_length = word_length * len(words)\n        word_count = {}\n\n        for word in words:\n            word_count[word] = word_count.get(word, 0) + 1\n\n        result = []\n\n        for i in range(len(s) - total_words_length + 1):\n            seen_words = {}\n            j = 0\n\n            while j < len(words):\n                word_index = i + j * word_length\n                word = s[word_index:word_index + word_length]\n\n                if word not in word_count:\n                    break\n                seen_words[word] = seen_words.get(word, 0) + 1\n\n                if seen_words[word] > word_count[word]:\n                    break\n                j += 1\n\n            if j == len(words):\n                result.append(i)\n\n        return result",
      "explanation": "## 📝 Problem Recap\nFind all starting indices of substring(s) in a string that is a concatenation of each word in a list exactly once.\n\n---\n\n## Step-by-Step Explanation\n\n **Edge Cases:**\n   - If the string or the list of words is empty, return an empty array.\n\n **Initialize Variables:**\n   - Calculate the length of each word and the total length of all words combined.\n   - Create a frequency map to count occurrences of each word in the list.\n\n **Iterate Through String:**\n   - Loop through the string up to the point where a full concatenation could fit.\n   - For each starting index, check if the substring matches the words in the list.\n   - Use a nested loop to check each segment of the substring against the frequency map.\n   - If all words are found with correct counts, add the starting index to the result.\n\n **Return Result:**\n   - Return an array of starting indices where the concatenation occurs."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> result = new ArrayList<>();\n        if (s.length() == 0 || words.length == 0) return result;\n\n        int wordLength = words[0].length();\n        int totalWordsLength = wordLength * words.length;\n        Map<String, Integer> wordCount = new HashMap<>();\n\n        for (String word : words) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n\n        for (int i = 0; i <= s.length() - totalWordsLength; i++) {\n            Map<String, Integer> seenWords = new HashMap<>();\n            int j = 0;\n\n            while (j < words.length) {\n                int wordIndex = i + j * wordLength;\n                String word = s.substring(wordIndex, wordIndex + wordLength);\n\n                if (!wordCount.containsKey(word)) break;\n                seenWords.put(word, seenWords.getOrDefault(word, 0) + 1);\n\n                if (seenWords.get(word) > wordCount.get(word)) break;\n                j++;\n            }\n\n            if (j == words.length) result.add(i);\n        }\n\n        return result;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind all starting indices of substring(s) in a string that is a concatenation of each word in a list exactly once.\n\n---\n\n## Step-by-Step Explanation\n\n **Edge Cases:**\n   - If the string or the list of words is empty, return an empty array.\n\n **Initialize Variables:**\n   - Calculate the length of each word and the total length of all words combined.\n   - Create a frequency map to count occurrences of each word in the list.\n\n **Iterate Through String:**\n   - Loop through the string up to the point where a full concatenation could fit.\n   - For each starting index, check if the substring matches the words in the list.\n   - Use a nested loop to check each segment of the substring against the frequency map.\n   - If all words are found with correct counts, add the starting index to the result.\n\n **Return Result:**\n   - Return an array of starting indices where the concatenation occurs."
    }
  ]
  },
{
  "slug": "31-next-permutation",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function nextPermutation(nums) {\n    let i = nums.length - 2;\n\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n\n    if (i >= 0) {\n        let j = nums.length - 1;\n        while (nums[j] <= nums[i]) {\n            j--;\n        }\n        [nums[i], nums[j]] = [nums[j], nums[i]];\n    }\n\n    let left = i + 1, right = nums.length - 1;\n    while (left < right) {\n        [nums[left], nums[right]] = [nums[right], nums[left]];\n        left++;\n        right--;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGenerate the next lexicographical permutation of a sequence of numbers.\n\n---\n\n## Step-by-Step Explanation\n\n **Find the Pivot:**\n   - Start from the end of the array and find the first pair where the earlier number is less than the later number. This is the pivot.\n\n **Find the Successor:**\n   - From the end of the array, find the first number that is greater than the pivot.\n   - Swap these two numbers.\n\n **Reverse Suffix:**\n   - Reverse the part of the array after the pivot to get the next permutation in lexicographical order."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        i = len(nums) - 2\n\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1\n",
      "explanation": "## 📝 Problem Recap\nGenerate the next lexicographical permutation of a sequence of numbers.\n\n---\n\n## Step-by-Step Explanation\n\n **Find the Pivot:**\n   - Start from the end of the array and find the first pair where the earlier number is less than the later number. This is the pivot.\n\n **Find the Successor:**\n   - From the end of the array, find the first number that is greater than the pivot.\n   - Swap these two numbers.\n\n **Reverse Suffix:**\n   - Reverse the part of the array after the pivot to get the next permutation in lexicographical order."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n\n        reverse(nums, i + 1);\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    private void reverse(int[] nums, int start) {\n        int left = start, right = nums.length - 1;\n        while (left < right) {\n            swap(nums, left, right);\n            left++;\n            right--;\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGenerate the next lexicographical permutation of a sequence of numbers.\n\n---\n\n## Step-by-Step Explanation\n\n **Find the Pivot:**\n   - Start from the end of the array and find the first pair where the earlier number is less than the later number. This is the pivot.\n\n **Find the Successor:**\n   - From the end of the array, find the first number that is greater than the pivot.\n   - Swap these two numbers.\n\n **Reverse Suffix:**\n   - Reverse the part of the array after the pivot to get the next permutation in lexicographical order."
    }
  ]
  },
{
  "slug": "32-longest-valid-parentheses",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function longestValidParentheses(s) {\n    let maxLength = 0;\n    const stack = [-1];\n\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '(') {\n            stack.push(i);\n        } else {\n            stack.pop();\n            if (stack.length === 0) {\n                stack.push(i);\n            } else {\n                maxLength = Math.max(maxLength, i - stack[stack.length - 1]);\n            }\n        }\n    }\n\n    return maxLength;\n}",
      "explanation": "## 📝 Problem Recap\nFind the length of the longest valid parentheses substring.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Stack:**\n   - Use a stack to keep track of indices. Start with -1 to handle edge cases.\n\n **Iterate Through String:**\n   - Loop through each character in the string.\n   - If it's an opening parenthesis '(', push its index onto the stack.\n   - If it's a closing parenthesis ')', pop from the stack.\n     - If the stack is empty after popping, push the current index as a new base.\n     - If not empty, calculate the length of the valid substring using the current index and the top of the stack.\n\n **Return Result:**\n   - Return the maximum length found."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        max_length = 0\n        stack = [-1]\n\n        for i in range(len(s)):\n            if s[i] == '(': \n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    max_length = max(max_length, i - stack[-1])\n\n        return max_length",
      "explanation": "## 📝 Problem Recap\nFind the length of the longest valid parentheses substring.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Stack:**\n   - Use a stack to keep track of indices. Start with -1 to handle edge cases.\n\n **Iterate Through String:**\n   - Loop through each character in the string.\n   - If it's an opening parenthesis '(', push its index onto the stack.\n   - If it's a closing parenthesis ')', pop from the stack.\n     - If the stack is empty after popping, push the current index as a new base.\n     - If not empty, calculate the length of the valid substring using the current index and the top of the stack.\n\n **Return Result:**\n   - Return the maximum length found."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int longestValidParentheses(String s) {\n        int maxLength = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i);\n                } else {\n                    maxLength = Math.max(maxLength, i - stack.peek());\n                }\n            }\n        }\n\n        return maxLength;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind the length of the longest valid parentheses substring.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Stack:**\n   - Use a stack to keep track of indices. Start with -1 to handle edge cases.\n\n **Iterate Through String:**\n   - Loop through each character in the string.\n   - If it's an opening parenthesis '(', push its index onto the stack.\n   - If it's a closing parenthesis ')', pop from the stack.\n     - If the stack is empty after popping, push the current index as a new base.\n     - If not empty, calculate the length of the valid substring using the current index and the top of the stack.\n\n **Return Result:**\n   - Return the maximum length found."
    }
  ]
  },
  {
  "slug": "33-search-in-rotated-sorted-array",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function search(nums, target) {\n    let left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n\n        if (nums[mid] === target) return mid;\n\n        if (nums[left] <= nums[mid]) { // Left half is sorted\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else { // Right half is sorted\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}",
      "explanation": "## 📝 Problem Recap\nSearch for a target value in a rotated sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set `left` to the start and `right` to the end of the array.\n\n **Binary Search Loop:**\n   - While `left` is less than or equal to `right`, calculate the middle index.\n   - If the middle element is the target, return its index.\n   - Check if the left half is sorted. If it is, determine if the target lies within this range.\n   - If not, check the right half similarly.\n\n **Return Result:**\n   - If the target is not found, return -1."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            if nums[left] <= nums[mid]: # Left half is sorted\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else: # Right half is sorted\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n        return -1",
      "explanation": "## 📝 Problem Recap\nSearch for a target value in a rotated sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set `left` to the start and `right` to the end of the array.\n\n **Binary Search Loop:**\n   - While `left` is less than or equal to `right`, calculate the middle index.\n   - If the middle element is the target, return its index.\n   - Check if the left half is sorted. If it is, determine if the target lies within this range.\n   - If not, check the right half similarly.\n\n **Return Result:**\n   - If the target is not found, return -1."
  },
  {
      "language": "Java",
      "code": "public class Solution {\n    public int search(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) return mid;\n\n            if (nums[left] <= nums[mid]) { // Left half is sorted\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else { // Right half is sorted\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nSearch for a target value in a rotated sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set `left` to the start and `right` to the end of the array.\n\n **Binary Search Loop:**\n   - While `left` is less than or equal to `right`, calculate the middle index.\n   - If the middle element is the target, return its index.\n   - Check if the left half is sorted. If it is, determine if the target lies within this range.\n   - If not, check the right half similarly.\n\n **Return Result:**\n   - If the target is not found, return -1."
    }
  ]
  },
{
  "slug": "34-find-first-and-last-position-of-element-in-sorted-array",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function searchRange(nums, target) {\n    const result = [-1, -1];\n\n    let left = 0, right = nums.length - 1;\n\n    // Find the leftmost index\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    if (left >= nums.length || nums[left] !== target) return result;\n    result[0] = left;\n\n    // Reset right pointer for finding the rightmost index\n    right = nums.length - 1;\n\n    // Find the rightmost index\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (nums[mid] <= target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    result[1] = right;\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nFind the first and last position of a target value in a sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Start with a result array initialized to [-1, -1].\n\n **Binary Search for Leftmost Index:**\n   - Use binary search to find the leftmost index of the target.\n   - If found, update the first element of the result.\n\n **Binary Search for Rightmost Index:**\n   - Reset the right pointer and perform another binary search to find the rightmost index.\n   - Update the second element of the result.\n\n **Return Result:**\n   - Return the result array containing both indices."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        result = [-1, -1]\n\n        left, right = 0, len(nums) - 1\n\n        # Find the leftmost index\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        if left >= len(nums) or nums[left] != target:\n            return result\n        result[0] = left\n\n        # Reset right pointer for finding the rightmost index\n        right = len(nums) - 1\n\n        # Find the rightmost index\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] <= target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        result[1] = right\n        return result",
      "explanation": "## 📝 Problem Recap\nFind the first and last position of a target value in a sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Start with a result array initialized to [-1, -1].\n\n **Binary Search for Leftmost Index:**\n   - Use binary search to find the leftmost index of the target.\n   - If found, update the first element of the result.\n\n **Binary Search for Rightmost Index:**\n   - Reset the right pointer and perform another binary search to find the rightmost index.\n   - Update the second element of the result.\n\n **Return Result:**\n   - Return the result array containing both indices."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int[] result = {-1, -1};\n        int left = 0, right = nums.length - 1;\n\n        // Find the leftmost index\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        if (left >= nums.length || nums[left] != target) return result;\n        result[0] = left;\n\n        // Reset right pointer for finding the rightmost index\n        right = nums.length - 1;\n\n        // Find the rightmost index\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        result[1] = right;\n        return result;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind the first and last position of a target value in a sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Start with a result array initialized to [-1, -1].\n\n **Binary Search for Leftmost Index:**\n   - Use binary search to find the leftmost index of the target.\n   - If found, update the first element of the result.\n\n **Binary Search for Rightmost Index:**\n   - Reset the right pointer and perform another binary search to find the rightmost index.\n   - Update the second element of the result.\n\n **Return Result:**\n   - Return the result array containing both indices."
    }
  ]
},
{
  "slug": "35-search-insert-position",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function searchInsert(nums, target) {\n    let left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n\n        if (nums[mid] === target) return mid;\n\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return left;\n}",
      "explanation": "## 📝 Problem Recap\nFind the index at which a target value should be inserted into a sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set `left` to the start and `right` to the end of the array.\n\n **Binary Search Loop:**\n   - While `left` is less than or equal to `right`, calculate the middle index.\n   - If the middle element is equal to the target, return its index.\n   - If the middle element is less than the target, move the left pointer up.\n   - If it is greater, move the right pointer down.\n\n **Return Insert Position:**\n   - If the target is not found, return the left pointer as the insert position."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return left",
      "explanation": "## 📝 Problem Recap\nFind the index at which a target value should be inserted into a sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set `left` to the start and `right` to the end of the array.\n\n **Binary Search Loop:**\n   - While `left` is less than or equal to `right`, calculate the middle index.\n   - If the middle element is equal to the target, return its index.\n   - If the middle element is less than the target, move the left pointer up.\n   - If it is greater, move the right pointer down.\n\n **Return Insert Position:**\n   - If the target is not found, return the left pointer as the insert position."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) return mid;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind the index at which a target value should be inserted into a sorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set `left` to the start and `right` to the end of the array.\n\n **Binary Search Loop:**\n   - While `left` is less than or equal to `right`, calculate the middle index.\n   - If the middle element is equal to the target, return its index.\n   - If the middle element is less than the target, move the left pointer up.\n   - If it is greater, move the right pointer down.\n\n **Return Insert Position:**\n   - If the target is not found, return the left pointer as the insert position."
    }
  ]
},
{
  "slug": "36-valid-sudoku",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function isValidSudoku(board) {\n    const rows = Array(9).fill().map(() => new Set());\n    const cols = Array(9).fill().map(() => new Set());\n    const boxes = Array(9).fill().map(() => new Set());\n\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            const num = board[i][j];\n            if (num === '.') continue;\n\n            if (rows[i].has(num) || cols[j].has(num) || boxes[Math.floor(i / 3) * 3 + Math.floor(j / 3)].has(num)) {\n                return false;\n            }\n\n            rows[i].add(num);\n            cols[j].add(num);\n            boxes[Math.floor(i / 3) * 3 + Math.floor(j / 3)].add(num);\n        }\n    }\n\n    return true;\n}",
      "explanation": "## 📝 Problem Recap\nCheck if a given Sudoku board is valid.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Sets:**\n   - Create sets for each row, column, and 3x3 box to track seen numbers.\n\n **Iterate Through Board:**\n   - Loop through each cell in the board.\n   - If the cell is empty ('.'), skip it.\n   - Check if the number already exists in the corresponding row, column, or box.\n   - If it does, return false.\n   - Otherwise, add the number to the respective sets.\n\n **Return Result:**\n   - If no duplicates are found, return true."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for i in range(9):\n            for j in range(9):\n                num = board[i][j]\n                if num == '.':\n                    continue\n\n                if (num in rows[i] or\n                    num in cols[j] or\n                    num in boxes[(i // 3) * 3 + (j // 3)]):\n                    return False\n\n                rows[i].add(num)\n                cols[j].add(num)\n                boxes[(i // 3) * 3 + (j // 3)].add(num)\n\n        return True",
      "explanation": "## 📝 Problem Recap\nCheck if a given Sudoku board is valid.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Sets:**\n   - Create sets for each row, column, and 3x3 box to track seen numbers.\n\n **Iterate Through Board:**\n   - Loop through each cell in the board.\n   - If the cell is empty ('.'), skip it.\n   - Check if the number already exists in the corresponding row, column, or box.\n   - If it does, return false.\n   - Otherwise, add the number to the respective sets.\n\n **Return Result:**\n   - If no duplicates are found, return true."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        Set<Character>[] rows = new HashSet[9];\n        Set<Character>[] cols = new HashSet[9];\n        Set<Character>[] boxes = new HashSet[9];\n\n        for (int i = 0; i < 9; i++) {\n            rows[i] = new HashSet<>();\n            cols[i] = new HashSet<>();\n            boxes[i] = new HashSet<>();\n        }\n\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char num = board[i][j];\n                if (num == '.') continue;\n\n                if (rows[i].contains(num) || cols[j].contains(num) || boxes[(i / 3) * 3 + (j / 3)].contains(num)) {\n                    return false;\n                }\n\n                rows[i].add(num);\n                cols[j].add(num);\n                boxes[(i / 3) * 3 + (j / 3)].add(num);\n            }\n        }\n\n        return true;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nCheck if a given Sudoku board is valid.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Sets:**\n   - Create sets for each row, column, and 3x3 box to track seen numbers.\n\n **Iterate Through Board:**\n   - Loop through each cell in the board.\n   - If the cell is empty ('.'), skip it.\n   - Check if the number already exists in the corresponding row, column, or box.\n   - If it does, return false.\n   - Otherwise, add the number to the respective sets.\n\n **Return Result:**\n   - If no duplicates are found, return true."
}
  ]
},
{
  "slug": "37-sudoku-solver",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function solveSudoku(board) {\n    const isValid = (row, col, num) => {\n        for (let i = 0; i < 9; i++) {\n            if (board[row][i] === num || board[i][col] === num ||\n                board[Math.floor(row / 3) * 3 + Math.floor(i / 3)][Math.floor(col / 3) * 3 + i % 3] === num) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    const solve = () => {\n        for (let row = 0; row < 9; row++) {\n            for (let col = 0; col < 9; col++) {\n                if (board[row][col] === '.') {\n                    for (let num = '1'; num <= '9'; num++) {\n                        if (isValid(row, col, num)) {\n                            board[row][col] = num;\n                            if (solve()) return true;\n                            board[row][col] = '.'; // backtrack\n                        }\n                    }\n                    return false; // no valid number found\n                }\n            }\n        }\n        return true; // solved\n    };\n\n    solve();\n}",
      "explanation": "## 📝 Problem Recap\nSolve a given Sudoku puzzle by filling in the empty cells.\n\n---\n\n## Step-by-Step Explanation\n\n **Validation Function:**\n   - Create a function to check if placing a number in a specific cell is valid.\n   - Check the row, column, and corresponding 3x3 box for duplicates.\n\n **Backtracking Function:**\n   - Loop through each cell in the board.\n   - If an empty cell is found, try placing numbers from '1' to '9'.\n   - If a number is valid, place it and recursively call the solve function.\n   - If the recursive call returns true, the board is solved.\n   - If not, backtrack by resetting the cell to '.' and trying the next number.\n\n ** Return Result:**\n   - The board is modified in place, so no return value is needed."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        def isValid(row, col, num):\n            for i in range(9):\n                if (board[row][i] == num or\n                    board[i][col] == num or\n                    board[(row // 3) * 3 + (i // 3)][(col // 3) * 3 + i % 3] == num):\n                    return False\n            return True\n\n        def solve():\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        for num in '123456789':\n                            if isValid(row, col, num):\n                                board[row][col] = num\n                                if solve(): return True\n                                board[row][col] = '.' # backtrack\n                        return False # no valid number found\n            return True # solved\n\n        solve()",
      "explanation": "## 📝 Problem Recap\nSolve a given Sudoku puzzle by filling in the empty cells.\n\n---\n\n## Step-by-Step Explanation\n\n **Validation Function:**\n   - Create a function to check if placing a number in a specific cell is valid.\n   - Check the row, column, and corresponding 3x3 box for duplicates.\n\n **Backtracking Function:**\n   - Loop through each cell in the board.\n   - If an empty cell is found, try placing numbers from '1' to '9'.\n   - If a number is valid, place it and recursively call the solve function.\n   - If the recursive call returns true, the board is solved.\n   - If not, backtrack by resetting the cell to '.' and trying the next number.\n\n ** Return Result:**\n   - The board is modified in place, so no return value is needed."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public void solveSudoku(char[][] board) {\n        boolean isValid(int row, int col, char num) {\n            for (int i = 0; i < 9; i++) {\n                if (board[row][i] == num ||\n                    board[i][col] == num ||\n                    board[(row / 3) * 3 + (i / 3)][(col / 3) * 3 + i % 3] == num) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        boolean solve() {\n            for (int row = 0; row < 9; row++) {\n                for (int col = 0; col < 9; col++) {\n                    if (board[row][col] == '.') {\n                        for (char num = '1'; num <= '9'; num++) {\n                            if (isValid(row, col, num)) {\n                                board[row][col] = num;\n                                if (solve()) return true;\n                                board[row][col] = '.'; // backtrack\n                            }\n                        }\n                        return false; // no valid number found\n                    }\n                }\n            }\n            return true; // solved\n        }\n\n        solve();\n    }\n}",
      "explanation": "## 📝 Problem Recap\nSolve a given Sudoku puzzle by filling in the empty cells.\n\n---\n\n## Step-by-Step Explanation\n\n **Validation Function:**\n   - Create a function to check if placing a number in a specific cell is valid.\n   - Check the row, column, and corresponding 3x3 box for duplicates.\n\n **Backtracking Function:**\n   - Loop through each cell in the board.\n   - If an empty cell is found, try placing numbers from '1' to '9'.\n   - If a number is valid, place it and recursively call the solve function.\n   - If the recursive call returns true, the board is solved.\n   - If not, backtrack by resetting the cell to '.' and trying the next number.\n\n ** Return Result:**\n   - The board is modified in place, so no return value is needed."
    }
  ]
  },
  {
  "slug": "38-count-and-say",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function countAndSay(n) {\n    if (n === 1) return '1';\n\n    let prev = countAndSay(n - 1);\n    let result = '';\n    let count = 1;\n\n    for (let i = 0; i < prev.length; i++) {\n        if (prev[i] === prev[i + 1]) {\n            count++;\n        } else {\n            result += count + prev[i];\n            count = 1;\n        }\n    }\n\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nGenerate the nth term of the 'Count and Say' sequence.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If n is 1, return '1'.\n\n **Recursive Call:**\n   - Call the function recursively to get the previous term.\n\n **Count and Say Logic:**\n   - Initialize an empty result string and a count variable.\n   - Loop through the previous term, counting consecutive characters.\n   - Append the count and character to the result string when a different character is encountered.\n\n **Return Result:**\n   - Return the generated string."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        if n == 1:\n            return '1'\n\n        prev = self.countAndSay(n - 1)\n        result = ''\n        count = 1\n\n        for i in range(len(prev)):\n            if i < len(prev) - 1 and prev[i] == prev[i + 1]:\n                count += 1\n            else:\n                result += str(count) + prev[i]\n                count = 1\n\n        return result",
      "explanation": "## 📝 Problem Recap\nGenerate the nth term of the 'Count and Say' sequence.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If n is 1, return '1'.\n\n **Recursive Call:**\n   - Call the function recursively to get the previous term.\n\n **Count and Say Logic:**\n   - Initialize an empty result string and a count variable.\n   - Loop through the previous term, counting consecutive characters.\n   - Append the count and character to the result string when a different character is encountered.\n\n **Return Result:**\n   - Return the generated string."
  },
  {
      "language": "Java",
      "code": "public class Solution {\n    public String countAndSay(int n) {\n        if (n == 1) return \"1\";\n\n        String prev = countAndSay(n - 1);\n        StringBuilder result = new StringBuilder();\n        int count = 1;\n\n        for (int i = 0; i < prev.length(); i++) {\n            if (i < prev.length() - 1 && prev.charAt(i) == prev.charAt(i + 1)) {\n                count++;\n            } else {\n                result.append(count).append(prev.charAt(i));\n                count = 1;\n            }\n        }\n\n        return result.toString();\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGenerate the nth term of the 'Count and Say' sequence.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Case:**\n   - If n is 1, return '1'.\n\n **Recursive Call:**\n   - Call the function recursively to get the previous term.\n\n **Count and Say Logic:**\n   - Initialize an empty result string and a count variable.\n   - Loop through the previous term, counting consecutive characters.\n   - Append the count and character to the result string when a different character is encountered.\n\n **Return Result:**\n   - Return the generated string."
    }
  ]
  },
  {
  "slug": "39-combination-sum",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function combinationSum(candidates, target) {\n    const result = [];\n\n    function backtrack(start, path, remaining) {\n        if (remaining === 0) {\n            result.push([...path]);\n            return;\n        }\n        if (remaining < 0) return;\n\n        for (let i = start; i < candidates.length; i++) {\n            path.push(candidates[i]);\n            backtrack(i, path, remaining - candidates[i]);\n            path.pop();\n        }\n    }\n\n    backtrack(0, [], target);\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nFind all unique combinations of numbers that sum up to a target value.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Create an empty array to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that explores combinations.\n   - If the remaining target is zero, add the current path to the result.\n   - If it goes below zero, return.\n   - Loop through candidates starting from the current index to avoid duplicates.\n   - Add the candidate to the path and recursively call the function with updated parameters.\n   - Backtrack by removing the last added candidate.\n\n **Return Result:**\n   - After exploring all combinations, return the result array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        result = []\n\n        def backtrack(start, path, remaining):\n            if remaining == 0:\n                result.append(path[:])\n                return\n            if remaining < 0:\n                return\n\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, remaining - candidates[i])\n                path.pop()\n\n        backtrack(0, [], target)\n        return result",
      "explanation": "## 📝 Problem Recap\nFind all unique combinations of numbers that sum up to a target value.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Create an empty array to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that explores combinations.\n   - If the remaining target is zero, add the current path to the result.\n   - If it goes below zero, return.\n   - Loop through candidates starting from the current index to avoid duplicates.\n   - Add the candidate to the path and recursively call the function with updated parameters.\n   - Backtrack by removing the last added candidate.\n\n **Return Result:**\n   - After exploring all combinations, return the result array."
    },
    {
      "language": "Java",
      "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(candidates, target, 0, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void backtrack(int[] candidates, int target, int start, List<Integer> path, List<List<Integer>> result) {\n        if (target == 0) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n        if (target < 0) return;\n\n        for (int i = start; i < candidates.length; i++) {\n            path.add(candidates[i]);\n            backtrack(candidates, target - candidates[i], i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind all unique combinations of numbers that sum up to a target value.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Create an empty list to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that explores combinations.\n   - If the remaining target is zero, add the current path to the result.\n   - If it goes below zero, return.\n   - Loop through candidates starting from the current index to avoid duplicates.\n   - Add the candidate to the path and recursively call the function with updated parameters.\n   - Backtrack by removing the last added candidate.\n\n **Return Result:**\n   - After exploring all combinations, return the result list."
    }
  ]
},
{
  "slug": "40-combination-sum-ii",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function combinationSum2(candidates, target) {\n    candidates.sort((a, b) => a - b);\n    const result = [];\n\n    function backtrack(start, path, remaining) {\n        if (remaining === 0) {\n            result.push([...path]);\n            return;\n        }\n        if (remaining < 0) return;\n\n        for (let i = start; i < candidates.length; i++) {\n            if (i > start && candidates[i] === candidates[i - 1]) continue; // skip duplicates\n            path.push(candidates[i]);\n            backtrack(i + 1, path, remaining - candidates[i]);\n            path.pop();\n        }\n    }\n\n    backtrack(0, [], target);\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nFind all unique combinations of numbers that sum up to a target value, allowing each number to be used only once.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort Candidates:**\n   - Sort the candidates array to handle duplicates easily.\n\n **Initialize Result:**\n   - Create an empty array to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that explores combinations.\n   - If the remaining target is zero, add the current path to the result.\n   - If it goes below zero, return.\n   - Loop through candidates starting from the current index.\n   - Skip duplicates by checking if the current candidate is the same as the previous one.\n   - Add the candidate to the path and recursively call the function with updated parameters.\n   - Backtrack by removing the last added candidate.\n\n **Return Result:**\n   - After exploring all combinations, return the result array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        result = []\n\n        def backtrack(start, path, remaining):\n            if remaining == 0:\n                result.append(path[:])\n                return\n            if remaining < 0:\n                return\n\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue  # skip duplicates\n                path.append(candidates[i])\n                backtrack(i + 1, path, remaining - candidates[i])\n                path.pop()\n\n        backtrack(0, [], target)\n        return result",
      "explanation": "## 📝 Problem Recap\nFind all unique combinations of numbers that sum up to a target value, allowing each number to be used only once.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort Candidates:**\n   - Sort the candidates array to handle duplicates easily.\n\n **Initialize Result:**\n   - Create an empty array to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that explores combinations.\n   - If the remaining target is zero, add the current path to the result.\n   - If it goes below zero, return.\n   - Loop through candidates starting from the current index.\n   - Skip duplicates by checking if the current candidate is the same as the previous one.\n   - Add the candidate to the path and recursively call the function with updated parameters.\n   - Backtrack by removing the last added candidate.\n\n **Return Result:**\n   - After exploring all combinations, return the result array."
},
{
      "language": "Java",
      "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(candidates, target, 0, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void backtrack(int[] candidates, int target, int start, List<Integer> path, List<List<Integer>> result) {\n        if (target == 0) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n        if (target < 0) return;\n\n        for (int i = start; i < candidates.length; i++) {\n            if (i > start && candidates[i] == candidates[i - 1]) continue; // skip duplicates\n            path.add(candidates[i]);\n            backtrack(candidates, target - candidates[i], i + 1, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind all unique combinations of numbers that sum up to a target value, allowing each number to be used only once.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort Candidates:**\n   - Sort the candidates array to handle duplicates easily.\n\n **Initialize Result:**\n   - Create an empty list to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that explores combinations.\n   - If the remaining target is zero, add the current path to the result.\n   - If it goes below zero, return.\n   - Loop through candidates starting from the current index.\n   - Skip duplicates by checking if the current candidate is the same as the previous one.\n   - Add the candidate to the path and recursively call the function with updated parameters.\n   - Backtrack by removing the last added candidate.\n\n **Return Result:**\n   - After exploring all combinations, return the result list."
}
  ]
},
{
  "slug": "41-first-missing-positive",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function firstMissingPositive(nums) {\n    const n = nums.length;\n\n    for (let i = 0; i < n; i++) {\n        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            const temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (nums[i] !== i + 1) return i + 1;\n    }\n\n    return n + 1;\n}",
      "explanation": "## 📝 Problem Recap\nFind the smallest missing positive integer from an unsorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Rearrange Array:**\n   - Iterate through the array and place each number in its correct index position if it is within the range [1, n].\n   - Use a while loop to swap elements until each number is in its correct position.\n\n **Check for Missing Positive:**\n   - After rearranging, iterate through the array again.\n   - If the number at index `i` is not `i + 1`, then `i + 1` is the first missing positive integer.\n\n **Return Result:**\n   - If all numbers are in their correct positions, return `n + 1`."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        n = len(nums)\n\n        for i in range(n):\n            while 0 < nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                temp = nums[i]\n                nums[i], nums[temp - 1] = nums[temp - 1], temp\n\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n\n        return n + 1",
      "explanation": "## 📝 Problem Recap\nFind the smallest missing positive integer from an unsorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Rearrange Array:**\n   - Iterate through the array and place each number in its correct index position if it is within the range [1, n].\n   - Use a while loop to swap elements until each number is in its correct position.\n\n **Check for Missing Positive:**\n   - After rearranging, iterate through the array again.\n   - If the number at index `i` is not `i + 1`, then `i + 1` is the first missing positive integer.\n\n **Return Result:**\n   - If all numbers are in their correct positions, return `n + 1`."
   },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n\n        for (int i = 0; i < n; i++) {\n            while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                int temp = nums[i];\n                nums[i] = nums[temp - 1];\n                nums[temp - 1] = temp;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != i + 1) return i + 1;\n        }\n\n        return n + 1;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind the smallest missing positive integer from an unsorted array.\n\n---\n\n## Step-by-Step Explanation\n\n **Rearrange Array:**\n   - Iterate through the array and place each number in its correct index position if it is within the range [1, n].\n   - Use a while loop to swap elements until each number is in its correct position.\n\n **Check for Missing Positive:**\n   - After rearranging, iterate through the array again.\n   - If the number at index `i` is not `i + 1`, then `i + 1` is the first missing positive integer.\n\n **Return Result:**\n   - If all numbers are in their correct positions, return `n + 1`."
    }
  ]
},
{
  "slug": "42-trapping-rain-water",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function trap(height) {\n    const n = height.length;\n    if (n === 0) return 0;\n\n    let left = 0, right = n - 1;\n    let leftMax = height[left], rightMax = height[right];\n    let waterTrapped = 0;\n\n    while (left < right) {\n        if (leftMax < rightMax) {\n            left++;\n            leftMax = Math.max(leftMax, height[left]);\n            waterTrapped += leftMax - height[left];\n        } else {\n            right--;\n            rightMax = Math.max(rightMax, height[right]);\n            waterTrapped += rightMax - height[right];\n        }\n    }\n\n    return waterTrapped;\n}",
      "explanation": "## 📝 Problem Recap\nCalculate the amount of rainwater that can be trapped between the bars represented by an array of heights.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set two pointers, `left` at the start and `right` at the end of the array.\n   - Initialize `leftMax` and `rightMax` to track the maximum heights from both ends.\n   - Initialize a variable to accumulate the total water trapped.\n\n **Two-Pointer Technique:**\n   - While `left` is less than `right`, compare `leftMax` and `rightMax`.\n   - If `leftMax` is less than `rightMax`, move the left pointer up, update `leftMax`, and calculate trapped water.\n   - Otherwise, move the right pointer down, update `rightMax`, and calculate trapped water.\n\n **Return Result:**\n   - After processing all bars, return the total water trapped."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def trap(self, height: List[int]) -> int:\n        n = len(height)\n        if n == 0:\n            return 0\n\n        left, right = 0, n - 1\n        leftMax, rightMax = height[left], height[right]\n        waterTrapped = 0\n\n        while left < right:\n            if leftMax < rightMax:\n                left += 1\n                leftMax = max(leftMax, height[left])\n                waterTrapped += leftMax - height[left]\n            else:\n                right -= 1\n                rightMax = max(rightMax, height[right])\n                waterTrapped += rightMax - height[right]\n\n        return waterTrapped",
      "explanation": "## 📝 Problem Recap\nCalculate the amount of rainwater that can be trapped between the bars represented by an array of heights.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set two pointers, `left` at the start and `right` at the end of the array.\n   - Initialize `leftMax` and `rightMax` to track the maximum heights from both ends.\n   - Initialize a variable to accumulate the total water trapped.\n\n **Two-Pointer Technique:**\n   - While `left` is less than `right`, compare `leftMax` and `rightMax`.\n   - If `leftMax` is less than `rightMax`, move the left pointer up, update `leftMax`, and calculate trapped water.\n   - Otherwise, move the right pointer down, update `rightMax`, and calculate trapped water.\n\n **Return Result:**\n   - After processing all bars, return the total water trapped."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public int trap(int[] height) {\n        int n = height.length;\n        if (n == 0) return 0;\n\n        int left = 0, right = n - 1;\n        int leftMax = height[left], rightMax = height[right];\n        int waterTrapped = 0;\n\n        while (left < right) {\n            if (leftMax < rightMax) {\n                left++;\n                leftMax = Math.max(leftMax, height[left]);\n                waterTrapped += leftMax - height[left];\n            } else {\n                right--;\n                rightMax = Math.max(rightMax, height[right]);\n                waterTrapped += rightMax - height[right];\n            }\n        }\n\n        return waterTrapped;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nCalculate the amount of rainwater that can be trapped between the bars represented by an array of heights.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Pointers:**\n   - Set two pointers, `left` at the start and `right` at the end of the array.\n   - Initialize `leftMax` and `rightMax` to track the maximum heights from both ends.\n   - Initialize a variable to accumulate the total water trapped.\n\n **Two-Pointer Technique:**\n   - While `left` is less than `right`, compare `leftMax` and `rightMax`.\n   - If `leftMax` is less than `rightMax`, move the left pointer up, update `leftMax`, and calculate trapped water.\n   - Otherwise, move the right pointer down, update `rightMax`, and calculate trapped water.\n\n **Return Result:**\n   - After processing all bars, return the total water trapped."
    }
  ]
},
{
  "slug": "43-multiply-strings",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function multiply(num1, num2) {\n    if (num1 === '0' || num2 === '0') return '0';\n\n    const m = num1.length, n = num2.length;\n    const result = Array(m + n).fill(0);\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            const mul = (num1[i] - '0') * (num2[j] - '0');\n            const sum = mul + result[i + j + 1];\n            result[i + j + 1] = sum % 10;\n            result[i + j] += Math.floor(sum / 10);\n        }\n    }\n\n    return result.join('').replace(/^0+/, '') || '0';\n}",
      "explanation": "## 📝 Problem Recap\nMultiply two non-negative integers represented as strings and return the product as a string.\n\n---\n\n## Step-by-Step Explanation\n\n **Edge Case:**\n   - If either number is '0', return '0'.\n\n **Initialize Result Array:**\n   - Create an array to hold the intermediate results, sized to hold the maximum possible digits.\n\n **Nested Loop for Multiplication:**\n   - Loop through each digit of `num1` and `num2` in reverse order.\n   - Multiply the digits and add the result to the appropriate position in the result array.\n   - Handle carry-over by updating adjacent positions in the result array.\n\n **Format Result:**\n   - Join the result array into a string and remove leading zeros."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        if num1 == '0' or num2 == '0':\n            return '0'\n\n        m, n = len(num1), len(num2)\n        result = [0] * (m + n)\n\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n                sum_ = mul + result[i + j + 1]\n                result[i + j + 1] = sum_ % 10\n                result[i + j] += sum_ // 10\n\n        return ''.join(map(str, result)).lstrip('0') or '0'",
      "explanation": "## 📝 Problem Recap\nMultiply two non-negative integers represented as strings and return the product as a string.\n\n---\n\n## Step-by-Step Explanation\n\n **Edge Case:**\n   - If either number is '0', return '0'.\n\n **Initialize Result Array:**\n   - Create an array to hold the intermediate results, sized to hold the maximum possible digits.\n\n **Nested Loop for Multiplication:**\n   - Loop through each digit of `num1` and `num2` in reverse order.\n   - Multiply the digits and add the result to the appropriate position in the result array.\n   - Handle carry-over by updating adjacent positions in the result array.\n\n **Format Result:**\n   - Join the result array into a string and remove leading zeros."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public String multiply(String num1, String num2) {\n        if (num1.equals(\"0\") || num2.equals(\"0\")) return \"0\";\n\n        int m = num1.length(), n = num2.length();\n        int[] result = new int[m + n];\n\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n                int sum = mul + result[i + j + 1];\n                result[i + j + 1] = sum % 10;\n                result[i + j] += sum / 10;\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int num : result) {\n            if (!(sb.length() == 0 && num == 0)) sb.append(num);\n        }\n\n        return sb.toString();\n    }\n}",
      "explanation": "## 📝 Problem Recap\nMultiply two non-negative integers represented as strings and return the product as a string.\n\n---\n\n## Step-by-Step Explanation\n\n **Edge Case:**\n   - If either number is '0', return '0'.\n\n **Initialize Result Array:**\n   - Create an array to hold the intermediate results, sized to hold the maximum possible digits.\n\n **Nested Loop for Multiplication:**\n   - Loop through each digit of `num1` and `num2` in reverse order.\n   - Multiply the digits and add the result to the appropriate position in the result array.\n   - Handle carry-over by updating adjacent positions in the result array.\n\n **Format Result:**\n   - Use a StringBuilder to construct the final string, skipping leading zeros."
    }
  ]
},
{
  "slug": "44-wildcard-matching",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function isMatch(s, p) {\n    const m = s.length, n = p.length;\n    const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= n; j++) {\n        if (p[j - 1] === '*') {\n            dp[0][j] = dp[0][j - 1];\n        }\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (p[j - 1] === s[i - 1] || p[j - 1] === '?') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] === '*') {\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n            }\n        }\n    }\n\n    return dp[m][n];\n}",
      "explanation": "## 📝 Problem Recap\nImplement wildcard pattern matching with support for '?' and '*'.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize DP Table:**\n   - Create a DP table of size `(m+1) x (n+1)` where `m` is the length of `s` and `n` is the length of `p`.\n   - Set `dp[0][0]` to true, indicating an empty string matches an empty pattern.\n\n **Handle Leading Wildcards:**\n   - Fill the first row of the DP table for patterns starting with '*'.\n\n **Fill DP Table:**\n   - Iterate through each character in `s` and `p`.\n   - If characters match or the pattern character is '?', set `dp[i][j]` based on the previous state.\n   - If the pattern character is '*', set `dp[i][j]` based on the previous character in `s` or the previous pattern character.\n\n **Return Result:**\n   - The result is found in `dp[m][n]`, indicating if the entire string matches the pattern."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                dp[0][j] = dp[0][j - 1]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == s[i - 1] or p[j - 1] == '?':\n                    dp[i][j] = dp[i - 1][j - 1]\n                elif p[j - 1] == '*':\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n\n        return dp[m][n]",
      "explanation": "## 📝 Problem Recap\nImplement wildcard pattern matching with support for '?' and '*'.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize DP Table:**\n   - Create a DP table of size `(m+1) x (n+1)` where `m` is the length of `s` and `n` is the length of `p`.\n   - Set `dp[0][0]` to true, indicating an empty string matches an empty pattern.\n\n **Handle Leading Wildcards:**\n   - Fill the first row of the DP table for patterns starting with '*'.\n\n **Fill DP Table:**\n   - Iterate through each character in `s` and `p`.\n   - If characters match or the pattern character is '?', set `dp[i][j]` based on the previous state.\n   - If the pattern character is '*', set `dp[i][j]` based on the previous character in `s` or the previous pattern character.\n\n **Return Result:**\n   - The result is found in `dp[m][n]`, indicating if the entire string matches the pattern."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public boolean isMatch(String s, String p) {\n        int m = s.length(), n = p.length();\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 1];\n            }\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '?') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n}",
      "explanation": "## 📝 Problem Recap\nImplement wildcard pattern matching with support for '?' and '*'.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize DP Table:**\n   - Create a DP table of size `(m+1) x (n+1)` where `m` is the length of `s` and `n` is the length of `p`.\n   - Set `dp[0][0]` to true, indicating an empty string matches an empty pattern.\n\n **Handle Leading Wildcards:**\n   - Fill the first row of the DP table for patterns starting with '*'.\n\n **Fill DP Table:**\n   - Iterate through each character in `s` and `p`.\n   - If characters match or the pattern character is '?', set `dp[i][j]` based on the previous state.\n   - If the pattern character is '*', set `dp[i][j]` based on the previous character in `s` or the previous pattern character.\n\n **Return Result:**\n   - The result is found in `dp[m][n]`, indicating if the entire string matches the pattern."
    }
  ]
},
{
  "slug": "45-jump-game-ii",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function jump(nums) {\n    let jumps = 0, currentEnd = 0, farthest = 0;\n\n    for (let i = 0; i < nums.length - 1; i++) {\n        farthest = Math.max(farthest, i + nums[i]);\n        if (i === currentEnd) {\n            jumps++;\n            currentEnd = farthest;\n        }\n    }\n\n    return jumps;\n}",
      "explanation": "## 📝 Problem Recap\nFind the minimum number of jumps to reach the last index of an array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Variables:**\n   - `jumps` to count the number of jumps made.\n   - `currentEnd` to track the end of the current jump range.\n   - `farthest` to track the farthest index reachable from the current jump range.\n\n **Iterate Through Array:**\n   - Loop through each index in the array except the last one.\n   - Update `farthest` with the maximum reachable index from the current position.\n   - If the current index reaches `currentEnd`, increment `jumps` and update `currentEnd` to `farthest`.\n\n **Return Result:**\n   - After processing all indices, return the total number of jumps."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        jumps = 0\n        currentEnd = 0\n        farthest = 0\n\n        for i in range(len(nums) - 1):\n            farthest = max(farthest, i + nums[i])\n            if i == currentEnd:\n                jumps += 1\n                currentEnd = farthest\n\n        return jumps",
      "explanation": "## 📝 Problem Recap\nFind the minimum number of jumps to reach the last index of an array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Variables:**\n   - `jumps` to count the number of jumps made.\n   - `currentEnd` to track the end of the current jump range.\n   - `farthest` to track the farthest index reachable from the current jump range.\n\n **Iterate Through Array:**\n   - Loop through each index in the array except the last one.\n   - Update `farthest` with the maximum reachable index from the current position.\n   - If the current index reaches `currentEnd`, increment `jumps` and update `currentEnd` to `farthest`.\n\n **Return Result:**\n   - After processing all indices, return the total number of jumps."
    },
{
      "language": "Java",
      "code": "public class Solution {\n    public int jump(int[] nums) {\n        int jumps = 0, currentEnd = 0, farthest = 0;\n\n        for (int i = 0; i < nums.length - 1; i++) {\n            farthest = Math.max(farthest, i + nums[i]);\n            if (i == currentEnd) {\n                jumps++;\n                currentEnd = farthest;\n            }\n        }\n\n        return jumps;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nFind the minimum number of jumps to reach the last index of an array.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Variables:**\n   - `jumps` to count the number of jumps made.\n   - `currentEnd` to track the end of the current jump range.\n   - `farthest` to track the farthest index reachable from the current jump range.\n\n **Iterate Through Array:**\n   - Loop through each index in the array except the last one.\n   - Update `farthest` with the maximum reachable index from the current position.\n   - If the current index reaches `currentEnd`, increment `jumps` and update `currentEnd` to `farthest`.\n\n **Return Result:**\n   - After processing all indices, return the total number of jumps."
    }
  ]
    
},{
  "slug": "46-permutations",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function permute(nums) {\n    const result = [];\n\n    function backtrack(path, remaining) {\n        if (remaining.length === 0) {\n            result.push(path);\n            return;\n        }\n\n        for (let i = 0; i < remaining.length; i++) {\n            const nextPath = path.concat(remaining[i]);\n            const nextRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1));\n            backtrack(nextPath, nextRemaining);\n        }\n    }\n\n    backtrack([], nums);\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nGenerate all possible permutations of a given array of numbers.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Create an empty array to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that builds permutations.\n   - If there are no remaining numbers, add the current path to the result.\n   - Loop through each number in the remaining array.\n   - For each number, create a new path and remaining array, then recursively call the function.\n\n **Return Result:**\n   - After exploring all permutations, return the result array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        result = []\n\n        def backtrack(path, remaining):\n            if not remaining:\n                result.append(path)\n                return\n\n            for i in range(len(remaining)):\n                nextPath = path + [remaining[i]]\n                nextRemaining = remaining[:i] + remaining[i + 1:]\n                backtrack(nextPath, nextRemaining)\n\n        backtrack([], nums)\n        return result",
      "explanation": "## 📝 Problem Recap\nGenerate all possible permutations of a given array of numbers.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Create an empty array to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that builds permutations.\n   - If there are no remaining numbers, add the current path to the result.\n   - Loop through each number in the remaining array.\n   - For each number, create a new path and remaining array, then recursively call the function.\n\n **Return Result:**\n   - After exploring all permutations, return the result array."
    },{
      "language": "Java",
      "code": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(new ArrayList<>(), nums, result);\n        return result;\n    }\n\n    private void backtrack(List<Integer> path, int[] remaining, List<List<Integer>> result) {\n        if (remaining.length == 0) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n\n        for (int i = 0; i < remaining.length; i++) {\n            path.add(remaining[i]);\n            int[] nextRemaining = new int[remaining.length - 1];\n            for (int j = 0, k = 0; j < remaining.length; j++) {\n                if (j != i) nextRemaining[k++] = remaining[j];\n            }\n            backtrack(path, nextRemaining, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGenerate all possible permutations of a given array of numbers.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Result:**\n   - Create an empty list to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that builds permutations.\n   - If there are no remaining numbers, add the current path to the result.\n   - Loop through each number in the remaining array.\n   - For each number, create a new path and remaining array, then recursively call the function.\n\n **Return Result:**\n   - After exploring all permutations, return the result list."
    }
  ]
},{
  "slug": "47-permutations-ii",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function permuteUnique(nums) {\n    const result = [];\n    nums.sort((a, b) => a - b);\n\n    function backtrack(path, remaining) {\n        if (remaining.length === 0) {\n            result.push(path);\n            return;\n        }\n\n        for (let i = 0; i < remaining.length; i++) {\n            if (i > 0 && remaining[i] === remaining[i - 1]) continue; // skip duplicates\n            const nextPath = path.concat(remaining[i]);\n            const nextRemaining = remaining.slice(0, i).concat(remaining.slice(i + 1));\n            backtrack(nextPath, nextRemaining);\n        }\n    }\n\n    backtrack([], nums);\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nGenerate all unique permutations of an array that may contain duplicates.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort Input:**\n   - Sort the input array to handle duplicates easily.\n\n **Initialize Result:**\n   - Create an empty array to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that builds permutations.\n   - If there are no remaining numbers, add the current path to the result.\n   - Loop through each number in the remaining array.\n   - Skip duplicates by checking if the current number is the same as the previous one.\n   - For each number, create a new path and remaining array, then recursively call the function.\n\n **Return Result:**\n   - After exploring all unique permutations, return the result array."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        nums.sort()\n        result = []\n\n        def backtrack(path, remaining):\n            if not remaining:\n                result.append(path)\n                return\n\n            for i in range(len(remaining)):\n                if i > 0 and remaining[i] == remaining[i - 1]:\n                    continue  # skip duplicates\n                nextPath = path + [remaining[i]]\n                nextRemaining = remaining[:i] + remaining[i + 1:]\n                backtrack(nextPath, nextRemaining)\n\n        backtrack([], nums)\n        return result",
      "explanation": "## 📝 Problem Recap\nGenerate all unique permutations of an array that may contain duplicates.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort Input:**\n   - Sort the input array to handle duplicates easily.\n\n **Initialize Result:**\n   - Create an empty array to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that builds permutations.\n   - If there are no remaining numbers, add the current path to the result.\n   - Loop through each number in the remaining array.\n   - Skip duplicates by checking if the current number is the same as the previous one.\n   - For each number, create a new path and remaining array, then recursively call the function.\n\n **Return Result:**\n   - After exploring all unique permutations, return the result array."
    },
    {
      "language": "Java",
      "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(new ArrayList<>(), nums, new boolean[nums.length], result);\n        return result;\n    }\n\n    private void backtrack(List<Integer> path, int[] nums, boolean[] used, List<List<Integer>> result) {\n        if (path.size() == nums.length) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue; // skip duplicates\n            used[i] = true;\n            path.add(nums[i]);\n            backtrack(path, nums, used, result);\n            path.remove(path.size() - 1);\n            used[i] = false;\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGenerate all unique permutations of an array that may contain duplicates.\n\n---\n\n## Step-by-Step Explanation\n\n **Sort Input:**\n   - Sort the input array to handle duplicates easily.\n\n **Initialize Result:**\n   - Create an empty list to store the results.\n\n **Backtracking Function:**\n   - Define a recursive function that builds permutations.\n   - If there are no remaining numbers, add the current path to the result.\n   - Loop through each number in the remaining array.\n   - Skip duplicates by checking if the current number is the same as the previous one.\n   - For each number, create a new path and remaining array, then recursively call the function.\n\n **Return Result:**\n   - After exploring all unique permutations, return the result list."
    }
  ]
},{
  "slug": "48-rotate-image",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function rotate(matrix) {\n    const n = matrix.length;\n\n    // Transpose the matrix\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n    }\n\n    // Reverse each row\n    for (let i = 0; i < n; i++) {\n        matrix[i].reverse();\n    }\n}",
      "explanation": "## 📝 Problem Recap\nRotate a square matrix by 90 degrees clockwise.\n\n---\n\n## Step-by-Step Explanation\n\n **Transpose the Matrix:**\n   - Swap elements across the diagonal to transpose the matrix.\n   - Iterate through the upper triangle of the matrix and swap elements with their counterparts in the lower triangle.\n\n **Reverse Each Row:**\n   - After transposing, reverse each row to achieve the final rotated matrix."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        n = len(matrix)\n\n        # Transpose the matrix\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        # Reverse each row\n        for i in range(n):\n            matrix[i].reverse()",
      "explanation": "## 📝 Problem Recap\nRotate a square matrix by 90 degrees clockwise.\n\n---\n\n## Step-by-Step Explanation\n\n **Transpose the Matrix:**\n   - Swap elements across the diagonal to transpose the matrix.\n   - Iterate through the upper triangle of the matrix and swap elements with their counterparts in the lower triangle.\n\n **Reverse Each Row:**\n   - After transposing, reverse each row to achieve the final rotated matrix."
    },
    {
      "language": "Java",
      "code": "public class Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n\n        // Transpose the matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n\n        // Reverse each row\n        for (int i = 0; i < n; i++) {\n            for (int j = 0, k = n - 1; j < k; j++, k--) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[i][k];\n                matrix[i][k] = temp;\n            }\n        }\n    }\n}",
      "explanation": "## 📝 Problem Recap\nRotate a square matrix by 90 degrees clockwise.\n\n---\n\n## Step-by-Step Explanation\n\n **Transpose the Matrix:**\n   - Swap elements across the diagonal to transpose the matrix.\n   - Iterate through the upper triangle of the matrix and swap elements with their counterparts in the lower triangle.\n\n **Reverse Each Row:**\n   - After transposing, reverse each row to achieve the final rotated matrix."
    }
  ]
},
{
  "slug": "49-group-anagrams",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function groupAnagrams(strs) {\n    const map = new Map();\n\n    for (const str of strs) {\n        const sortedStr = str.split('').sort().join('');\n        if (!map.has(sortedStr)) {\n            map.set(sortedStr, []);\n        }\n        map.get(sortedStr).push(str);\n    }\n\n    return Array.from(map.values());\n}",
      "explanation": "## 📝 Problem Recap\nGroup anagrams from a list of strings.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Map:**\n   - Create a map to store sorted strings as keys and their anagrams as values.\n\n **Iterate Through Strings:**\n   - For each string, sort its characters to create a key.\n   - If the key doesn't exist in the map, initialize it with an empty array.\n   - Push the original string into the array corresponding to the sorted key.\n\n **Return Result:**\n   - Convert the map values to an array and return it."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        anagrams = {}\n\n        for str_ in strs:\n            sorted_str = ''.join(sorted(str_))\n            if sorted_str not in anagrams:\n                anagrams[sorted_str] = []\n            anagrams[sorted_str].append(str_)\n\n        return list(anagrams.values())",
      "explanation": "## 📝 Problem Recap\nGroup anagrams from a list of strings.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Dictionary:**\n   - Create a dictionary to store sorted strings as keys and their anagrams as values.\n\n **Iterate Through Strings:**\n   - For each string, sort its characters to create a key.\n   - If the key doesn't exist in the dictionary, initialize it with an empty list.\n   - Append the original string to the list corresponding to the sorted key.\n\n **Return Result:**\n   - Convert the dictionary values to a list and return it."
    },
    {
      "language": "Java",
      "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> anagrams = new HashMap<>();\n\n        for (String str : strs) {\n            char[] chars = str.toCharArray();\n            Arrays.sort(chars);\n            String sortedStr = new String(chars);\n\n            anagrams.putIfAbsent(sortedStr, new ArrayList<>());\n            anagrams.get(sortedStr).add(str);\n        }\n\n        return new ArrayList<>(anagrams.values());\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGroup anagrams from a list of strings.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize Map:**\n   - Create a map to store sorted strings as keys and their anagrams as values.\n\n **Iterate Through Strings:**\n   - For each string, convert it to a character array, sort it, and create a key.\n   - If the key doesn't exist in the map, initialize it with an empty list.\n   - Add the original string to the list corresponding to the sorted key.\n\n **Return Result:**\n   - Convert the map values to a list and return it."
    }
  ]
},
{
  "slug": "50-powx-n",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function myPow(x, n) {\n    if (n === 0) return 1;\n    if (n < 0) return 1 / myPow(x, -n);\n\n    let result = 1;\n    while (n > 0) {\n        if (n % 2 === 1) result *= x;\n        x *= x;\n        n = Math.floor(n / 2);\n    }\n\n    return result;\n}",
      "explanation": "## 📝 Problem Recap\nCalculate `x` raised to the power of `n`.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Cases:**\n   - If `n` is `0`, return `1` (any number to the power of `0` is `1`).\n   - If `n` is negative, calculate the power for positive `-n` and return its reciprocal.\n\n **Iterative Power Calculation:**\n   - Use a loop to calculate the power iteratively.\n   - If `n` is odd, multiply the result by `x`.\n   - Square `x` and halve `n` in each iteration until `n` becomes `0`.\n\n **Return Result:**\n   - Return the final result after all iterations."
    },
    {
      "language": "Python",
      "code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n < 0:\n            return 1 / self.myPow(x, -n)\n\n        result = 1\n        while n > 0:\n            if n % 2 == 1:\n                result *= x\n            x *= x\n            n //= 2\n\n        return result",
      "explanation": "## 📝 Problem Recap\nCalculate `x` raised to the power of `n`.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Cases:**\n   - If `n` is `0`, return `1` (any number to the power of `0` is `1`).\n   - If `n` is negative, calculate the power for positive `-n` and return its reciprocal.\n\n **Iterative Power Calculation:**\n   - Use a loop to calculate the power iteratively.\n   - If `n` is odd, multiply the result by `x`.\n   - Square `x` and halve `n` in each iteration until `n` becomes `0`.\n\n **Return Result:**\n   - Return the final result after all iterations."
},{
      "language": "Java",
      "code": "public class Solution {\n    public double myPow(double x, int n) {\n        if (n == 0) return 1;\n        if (n < 0) return 1 / myPow(x, -n);\n\n        double result = 1;\n        while (n > 0) {\n            if (n % 2 == 1) result *= x;\n            x *= x;\n            n /= 2;\n        }\n\n        return result;\n    }\n}",
      "explanation": "## 📝 Problem Recap\nCalculate `x` raised to the power of `n`.\n\n---\n\n## Step-by-Step Explanation\n\n **Base Cases:**\n   - If `n` is `0`, return `1` (any number to the power of `0` is `1`).\n   - If `n` is negative, calculate the power for positive `-n` and return its reciprocal.\n\n **Iterative Power Calculation:**\n   - Use a loop to calculate the power iteratively.\n   - If `n` is odd, multiply the result by `x`.\n   - Square `x` and halve `n` in each iteration until `n` becomes `0`.\n\n **Return Result:**\n   - Return the final result after all iterations."
}
  ]
}
]