[
 
{
  "slug": "two-sum",
  "solutions": [
    {
      "language": "JavaScript",
      "code": "function twoSum(nums, target) {\n const map = new Map(); // stores num -> index\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return null;\n}",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize a Map:**\n   - `const map = new Map();`\n   - The map stores each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for (let i = 0; i < nums.length; i++)`\n   - Go through each element one by one.\n\n **Calculate the complement:**\n   - `const complement = target - nums[i];`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the map:**\n   - `if (map.has(complement))`\n   - If found, we have the solution.\n\n **Return the indices:**\n   - `return [map.get(complement), i];`\n   - Return the index of the complement and the current index.\n\n **Store the current number in the map:**\n   - `map.set(nums[i], i);`\n   - If the complement is not found, store the current number and its index.\n\n **Return null if no solution:**\n   - `return null;`\n   - If no pair adds up to the target, return `null`.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```js\nnums = [2, 7, 11, 15], target = 9\n```\n\n**Process:**\n- i = 0, nums[0] = 2 → complement = 7 → not in map → store 2 at index 0\n- i = 1, nums[1] = 7 → complement = 2 → found in map → return [0, 1]\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n- Hash maps provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    },

    {
      "language": "Python",
      "code": "class Solution:\n    def twoSum(self, nums, target):\n        map = {}\n        for i, num in enumerate(nums):\n            complement = target - num\n            if complement in map:\n                return (map[complement], i)\n            map[num] = i\n        return None",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Initialize a Dictionary:**\n   - `map = {}`\n   - This dictionary will store each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for i, num in enumerate(nums):`\n   - Iterate through each element with its index.\n\n **Calculate the complement:**\n   - `complement = target - num`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the dictionary:**\n   - `if complement in map:`\n   - If found, we have our solution.\n\n **Return the indices:**\n   - `return (map[complement], i)`\n   - Return the index of the complement and the current index.\n\n **Store the current number in the dictionary:**\n   - `map[num] = i`\n   - If the complement is not found, store the current number and its index.\n\n **Return None if no solution:**\n   - `return None`\n   - If no pair adds up to the target, return `None`.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```python\nnums = [2, 7, 11, 15], target = 9\n```\n\n**Process:**\n- i = 0, nums[0] = 2 → complement = 7 → not in map → store 2 at index 0\n- i = 1, nums[1] = 7 → complement = 2 → found in map → return (0, 1)\n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n- Dictionaries provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    }, 
    {
      "language": "Java",
      "code": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return new int[] { -1, -1 };  // No solution found\n    }\n}",
      "explanation": "## 📝 Problem Recap\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to the target.\n\n---\n\n## Step-by-Step Explanation\n\n **Import Required Classes:**\n   - `import java.util.HashMap;`\n   - `import java.util.Map;`\n   - These classes are used for creating a map to store numbers and their indices.\n\n **Define the Method:**\n   - `public int[] twoSum(int[] nums, int target)`\n   - This method takes an array of integers and a target integer as input.\n\n **Initialize a Map:**\n   - `Map<Integer, Integer> map = new HashMap<>();`\n   - The map will store each number and its index for quick lookup.\n\n **Loop through the array:**\n   - `for (int i = 0; i < nums.length; i++)`\n   - Iterate through each element with its index.\n\n **Calculate the complement:**\n   - `int complement = target - nums[i];`\n   - This is the number we need to find to reach the target sum.\n\n **Check if complement exists in the map:**\n   - `if (map.containsKey(complement))`\n   - If found, we have our solution.\n\n **Return the indices:**\n   - `return new int[] { map.get(complement), i };\n`- Return the index of the complement and the current index.\n\n **Store the current number in the map:**\n   - `map.put(nums[i], i);`\n   - If the complement is not found, store the current number and its index.\n\n **Return default value if no solution:**\n   - `return new int[] { -1, -1 };`\n   - If no pair adds up to the target, return an array indicating no solution was found.\n\n---\n\n## Example Walkthrough\n\n**Input:**\n```java\nint[] nums = {2, 7, 11, 15}, target = 9;\n```\n\n**Process:**\n- i = 0, nums[0] = 2 → complement = 7 → not in map → store 2 at index \n\n---\n\n## Time & Space Complexity\n- **Time Complexity:** O(n)\n- **Space Complexity:** O(n)\n\n---\n\n## Key Takeaways\n-- Hash maps provide fast lookups in O(1) time.\n- The algorithm efficiently finds the solution in one pass through the array.\n- Storing each number as we iterate is the key to this approach."
    }
  ]
}
]